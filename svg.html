<!doctype html>
<html lang="en">
<head>
    <!-- SEO Meta Tags -->
    <meta name="description" content="Free, open SVG logo editor with text-to-path, Google Fonts, custom font upload, and full vector editing.">
    <meta name="keywords" content="free svg editor, logo maker, vector editor, svg path editor, text to svg, google fonts svg, open source logo tool">
    <meta name="og:title" content="InkRealm — Free SVG Logo Editor">
    <meta name="og:description" content="Create, edit, and export SVG logos without tricks, paywalls, or AI traps.">
    <meta name="og:type" content="website">
    <meta name="robots" content="index, follow">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="/svg/favicon.svg" type="image/svg+xml">
<link rel="alternate icon" href="/svg/favicon.png" type="image/png">

  <title>InkRealm SVG - Logo Designer</title>
  <style>
    :root{--bg-primary:#ffffff;--bg-secondary:#f5f5f5;--bg-tertiary:#e0e0e0;--text-primary:#000000;--text-secondary:#666666;--border-color:#cccccc;--accent:#000000}
    [data-theme="dark"]{--bg-primary:#1a1a1a;--bg-secondary:#2a2a2a;--bg-tertiary:#3a3a3a;--text-primary:#ffffff;--text-secondary:#aaaaaa;--border-color:#444444;--accent:#ffffff}
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:var(--bg-primary);color:var(--text-primary);overflow:hidden}
    .app-container{display:flex;flex-direction:column;height:100vh}
    .toolbar{background:var(--bg-secondary);border-bottom:1px solid var(--border-color);padding:.5rem 1rem;display:flex;justify-content:space-between;align-items:center}
    .logo h1{font-size:1.25rem;font-weight:600;letter-spacing:-.02em}
    .toolbar-actions{display:flex;gap:.5rem;align-items:center}
    .btn{background:var(--bg-tertiary);border:1px solid var(--border-color);color:var(--text-primary);padding:.5rem 1rem;border-radius:4px;cursor:pointer;font-size:.875rem;transition:all .15s ease}
    .btn:hover{background:var(--accent);color:var(--bg-primary)}
    .btn-icon{padding:.5rem;display:flex;align-items:center;justify-content:center}
    .btn-secondary{background:transparent}
    .workspace{display:flex;flex:1;overflow:hidden}
    .tools-panel{width:280px;background:var(--bg-secondary);border-right:1px solid var(--border-color);padding:1rem;overflow-y:auto}
    .tool-group{margin-bottom:2rem}
    .tool-group h3{font-size:.875rem;font-weight:600;margin-bottom:1rem;text-transform:uppercase;letter-spacing:.05em;color:var(--text-secondary)}
    .tool-buttons{display:grid;grid-template-columns:repeat(3,1fr);gap:.5rem}
    .tool-btn{background:var(--bg-primary);border:1px solid var(--border-color);color:var(--text-primary);padding:1rem;border-radius:4px;cursor:pointer;transition:all .15s ease}
    .tool-btn:hover{border-color:var(--accent)}
    .tool-btn.active{background:var(--accent);color:var(--bg-primary)}
    .property-controls{display:flex;flex-direction:column;gap:1rem}
    .control-group{display:flex;flex-direction:column;gap:.5rem}
    .control-group label{font-size:.75rem;color:var(--text-secondary)}
    input[type=color]{width:100%;height:40px;border:1px solid var(--border-color);border-radius:4px;cursor:pointer}
    input[type=range]{width:100%}
    .layers-list{display:flex;flex-direction:column;gap:.5rem;margin-bottom:1rem}
    .layer-item{background:var(--bg-primary);border:1px solid var(--border-color);padding:.75rem;border-radius:4px;display:flex;justify-content:space-between;align-items:center;cursor:pointer}
    .layer-item.active{border-color:var(--accent)}
    .delete-layer{background:none;border:none;color:var(--text-secondary);cursor:pointer;font-size:1.25rem;padding:0;width:20px;height:20px;display:flex;align-items:center;justify-content:center}
    .canvas-container{flex:1;display:flex;align-items:center;justify-content:center;background:var(--bg-primary);position:relative}
    #main-canvas{background:var(--bg-primary);border:1px solid var(--border-color);box-shadow:0 4px 12px rgba(0,0,0,.08);cursor:crosshair}
    .dialog{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.5);align-items:center;justify-content:center;z-index:1000}
    .dialog.active{display:flex}
    .dialog-content{background:var(--bg-primary);padding:2rem;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,.2);display:flex;flex-direction:column;gap:1rem;min-width:300px}
    .dialog-content h3{margin-bottom:.5rem}
    .dialog-content input{padding:.75rem;border:1px solid var(--border-color);border-radius:4px;font-size:1rem}
    @media (max-width:768px){.tools-panel{width:240px}.tool-buttons{grid-template-columns:repeat(2,1fr)}}
    /* transition, scrollbar and focus */
    *{transition:background-color .25s ease,color .25s ease,border-color .25s ease}
    ::-webkit-scrollbar{width:8px;height:8px}
    ::-webkit-scrollbar-track{background:var(--bg-secondary)}
    ::-webkit-scrollbar-thumb{background:var(--border-color);border-radius:4px}
    ::-webkit-scrollbar-thumb:hover{background:var(--text-secondary)}
    button:focus,input:focus{outline:2px solid var(--accent);outline-offset:2px}
    input[type=range]{-webkit-appearance:none;appearance:none;height:4px;background:var(--border-color);border-radius:2px;outline:none}
    input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:16px;height:16px;background:var(--accent);border-radius:50%;cursor:pointer}
    input[type=color]{-webkit-appearance:none;appearance:none;padding:0;border:none;cursor:pointer}
    input[type=color]::-webkit-color-swatch-wrapper{padding:0}
    input[type=color]::-webkit-color-swatch{border:none;border-radius:4px}
    @media (max-width:480px){.toolbar-actions{gap:.25rem}.btn-icon{padding:.375rem}.logo h1{font-size:1rem}}
  </style>
</head>
<body>
  <div class="app-container">
    <header class="toolbar">
      <div class="logo"><h1>InkRealm SVG</h1></div>
      <div class="toolbar-actions">
        <button id="new-project" class="btn btn-icon" title="New Project">New</button>
        <button id="save-project" class="btn" title="Save Project">Save</button>
        <button id="load-project" class="btn" title="Load Project">Load</button>
        <button id="export-svg" class="btn" title="Export PNG/SVG">Export</button>
        <button id="theme-toggle" class="btn btn-icon" title="Toggle Theme">Theme</button>
        <!-- Font tools -->
        <!-- Font Manager -->
        <div id="font-manager" class="btn" style="padding:4px 8px; border:1px solid var(--border); border-radius:8px; margin-left:8px;">
          <strong>Font Manager</strong>
          <div style="margin-top:4px; font-size:12px;">
            <button id="show-font-list" class="btn">Show Fonts</button>
            <button id="clear-font-cache" class="btn">Clear Uploaded Fonts</button>
          </div>
        </div>
        <select id="font-select" class="btn" style="min-width:160px">
          <option value="">— Select font (Google Fonts) —</option>
          <option value="Roboto">Roboto</option>
          <option value="Montserrat">Montserrat</option>
          <option value="Open+Sans">Open Sans</option>
          <option value="Lato">Lato</option>
          <option value="Oswald">Oswald</option>
        </select>
        <input id="add-google-font" class="btn" placeholder="Add Google Font (e.g. Abril+Fatface)" style="min-width:180px"></input>
        <input id="upload-font" type="file" accept=".ttf,.otf,.woff,.woff2" style="display:none">
        <button id="upload-font-btn" class="btn" title="Upload Font">Upload Font</button>
        <button id="convert-text" class="btn" title="Convert selected text to path">Convert Text → Paths</button>
      </div>
    </header>

    <main class="workspace">
      <aside class="tools-panel">
        <div class="tool-group">
          <h3>Tools</h3>
          <div class="tool-buttons">
            <button class="tool-btn active" data-tool="select">Select</button>
            <button class="tool-btn" data-tool="rectangle">Rect</button>
            <button class="tool-btn" data-tool="circle">Circle</button>
            <button class="tool-btn" data-tool="path">Path</button>
            <button class="tool-btn" data-tool="text">Text</button>
          </div>
        </div>

        <div class="tool-group">
          <h3>Properties</h3>
          <div class="property-controls">
            <div class="control-group"><label>Fill</label><input type="color" id="fill-color" value="#000000"></div>
            <div class="control-group"><label>Stroke</label><input type="color" id="stroke-color" value="#000000"></div>
            <div class="control-group"><label>Stroke Width</label><input type="range" id="stroke-width" min="0" max="20" value="2"></div>
            <div class="control-group"><label>Opacity</label><input type="range" id="opacity" min="0" max="1" step="0.05" value="1"></div>
          </div>
        </div>

        <div class="tool-group">
          <h3>Layers</h3>
          <div class="layers-list" id="layers-list"></div>
          <button id="add-layer" class="btn">Add Layer</button>
        </div>
      </aside>

      <div class="canvas-container">
        <svg id="main-canvas" width="1000" height="700" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet">
          <defs id="svg-defs"></defs>
          <g id="svg-content"></g>
        </svg>
      </div>
    </main>
  </div>

  <div id="text-dialog" class="dialog"><div class="dialog-content"><h3>Text Properties</h3><input type="text" id="text-input" placeholder="Enter text"><input type="number" id="font-size" value="24"><div style="display:flex;gap:.5rem"><button id="apply-text" class="btn">Apply</button><button id="cancel-text" class="btn btn-secondary">Cancel</button></div></div></div>

  <input id="file-input" type="file" accept="application/json" style="display:none">

  <script>
  class InkRealmSVG {
    constructor() {
      this.canvas = document.getElementById('main-canvas');
      this.svgContent = document.getElementById('svg-content');
      this.currentTool = 'select';
      this.isDrawing = false;
      this.startPoint = null;
      this.currentElement = null;
      this.layers = [];
      this.activeLayer = 0; // index into layers array

      this.init();
    }

    init(){
      this.setupEventListeners();
      this.setupThemeToggle();
      this.setupTools();
      this.setupProperties();
      this.setupLayers();
      this.restoreIfAny();
    }

    setupEventListeners(){
      this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
      window.addEventListener('mousemove', this.handleMouseMove.bind(this));
      window.addEventListener('mouseup', this.handleMouseUp.bind(this));

      // touch support
      this.canvas.addEventListener('touchstart', e=>{e.preventDefault();const t=e.touches[0];this.handlePointerDown(t.clientX,t.clientY)});
      this.canvas.addEventListener('touchmove', e=>{e.preventDefault();const t=e.touches[0];this.handlePointerMove(t.clientX,t.clientY)});
      this.canvas.addEventListener('touchend', e=>{e.preventDefault();this.handlePointerUp();});

      document.getElementById('new-project').addEventListener('click', ()=>this.newProject());
      document.getElementById('save-project').addEventListener('click', ()=>this.saveProject());
      document.getElementById('load-project').addEventListener('click', ()=>document.getElementById('file-input').click());
      document.getElementById('export-svg').addEventListener('click', ()=>this.exportPNGAndSVG());
      document.getElementById('file-input').addEventListener('change', (e)=>this.loadFromFile(e));

      // text dialog buttons are wired where used
    }

    setupThemeToggle(){
      const themeToggle = document.getElementById('theme-toggle');
      const saved = localStorage.getItem('theme') || 'light';
      document.documentElement.setAttribute('data-theme', saved);
      themeToggle.addEventListener('click', ()=>{
        const cur = document.documentElement.getAttribute('data-theme') || 'light';
        const next = cur === 'light' ? 'dark' : 'light';
        document.documentElement.setAttribute('data-theme', next);
        localStorage.setItem('theme', next);
      });
    }

    setupTools(){
      document.querySelectorAll('.tool-btn').forEach(btn=>{btn.addEventListener('click', (e)=>{
        document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
        e.currentTarget.classList.add('active');
        this.currentTool = e.currentTarget.dataset.tool;
      })});
    }

    setupProperties(){
      ['fill-color','stroke-color','stroke-width','opacity'].forEach(id=>{
        document.getElementById(id).addEventListener('input', ()=>this.updateSelectedElement());
      });
    }

    setupLayers(){
      this.addLayer();
      document.getElementById('add-layer').addEventListener('click', ()=>this.addLayer());
    }

    // --- pointer abstractions ---
    handleMouseDown(e){
      const rect = this.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      this.handlePointerDown(e.clientX,e.clientY);
    }

    handleMouseMove(e){
      if(this.isDrawing) this.handlePointerMove(e.clientX,e.clientY);
    }

    handleMouseUp(e){
      if(this.isDrawing) this.handlePointerUp();
    }

    handlePointerDown(clientX,clientY){
      this.isDrawing = true;
      const pt = this.clientToSVG(clientX,clientY);
      this.startPoint = pt;

      if(this.currentTool === 'select'){
        this.selectAtPoint(clientX,clientY);
      } else if(this.currentTool === 'rectangle'){
        this.createRectangle(pt.x,pt.y);
      } else if(this.currentTool === 'circle'){
        this.createCircle(pt.x,pt.y);
      } else if(this.currentTool === 'path'){
        this.startPath(pt.x,pt.y);
      } else if(this.currentTool === 'text'){
        this.showTextDialog(clientX,clientY);
      }
    }

    handlePointerMove(clientX,clientY){
      if(!this.isDrawing || !this.currentElement) return;
      const pt = this.clientToSVG(clientX,clientY);
      this.updateShape(pt.x,pt.y);
    }

    handlePointerUp(){
      this.isDrawing = false;
      this.currentElement = null;
      this.startPoint = null;
    }

    clientToSVG(clientX,clientY){
      const pt = this.canvas.createSVGPoint();
      pt.x = clientX; pt.y = clientY;
      const ctm = this.canvas.getScreenCTM().inverse();
      const transformed = pt.matrixTransform(ctm);
      return {x: transformed.x, y: transformed.y};
    }

    // --- creation ---
    createRectangle(x,y){
      const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
      rect.setAttribute('x', x);
      rect.setAttribute('y', y);
      rect.setAttribute('width', 0);
      rect.setAttribute('height', 0);
      rect.setAttribute('fill', document.getElementById('fill-color').value);
      rect.setAttribute('stroke', document.getElementById('stroke-color').value);
      rect.setAttribute('stroke-width', document.getElementById('stroke-width').value);
      rect.setAttribute('opacity', document.getElementById('opacity').value);
      rect.addEventListener('mousedown', (e)=>{e.stopPropagation(); this.selectElement(rect);});
      this.currentElement = rect;
      this.getActiveLayerGroup().appendChild(rect);
    }

    createCircle(x,y){
      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circle.setAttribute('cx', x);
      circle.setAttribute('cy', y);
      circle.setAttribute('r', 0);
      circle.setAttribute('fill', document.getElementById('fill-color').value);
      circle.setAttribute('stroke', document.getElementById('stroke-color').value);
      circle.setAttribute('stroke-width', document.getElementById('stroke-width').value);
      circle.setAttribute('opacity', document.getElementById('opacity').value);
      circle.addEventListener('mousedown', (e)=>{e.stopPropagation(); this.selectElement(circle);});
      this.currentElement = circle;
      this.getActiveLayerGroup().appendChild(circle);
    }

    startPath(x,y){
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d', `M ${x} ${y}`);
      path.setAttribute('fill','none');
      path.setAttribute('stroke', document.getElementById('stroke-color').value);
      path.setAttribute('stroke-width', document.getElementById('stroke-width').value);
      path.setAttribute('opacity', document.getElementById('opacity').value);
      path.addEventListener('mousedown', (e)=>{e.stopPropagation(); this.selectElement(path);});
      this.currentElement = path;
      this.getActiveLayerGroup().appendChild(path);
    }

    updateShape(x,y){
      if(!this.currentElement) return;
      const tag = this.currentElement.tagName.toLowerCase();
      if(tag === 'rect'){
        const startX = parseFloat(this.currentElement.getAttribute('x'));
        const startY = parseFloat(this.currentElement.getAttribute('y'));
        const width = x - startX;
        const height = y - startY;
        this.currentElement.setAttribute('width', Math.abs(width));
        this.currentElement.setAttribute('height', Math.abs(height));
        if(width < 0) this.currentElement.setAttribute('x', x);
        if(height < 0) this.currentElement.setAttribute('y', y);
      } else if(tag === 'circle'){
        const cx = parseFloat(this.currentElement.getAttribute('cx'));
        const cy = parseFloat(this.currentElement.getAttribute('cy'));
        const r = Math.sqrt(Math.pow(x-cx,2)+Math.pow(y-cy,2));
        this.currentElement.setAttribute('r', r);
      } else if(tag === 'path'){
        const d = this.currentElement.getAttribute('d');
        this.currentElement.setAttribute('d', d + ` L ${x} ${y}`);
      }
    }

    showTextDialog(clientX,clientY){
      const dialog = document.getElementById('text-dialog');
      dialog.classList.add('active');
      const apply = document.getElementById('apply-text');
      const cancel = document.getElementById('cancel-text');
      const input = document.getElementById('text-input');
      const size = document.getElementById('font-size');
      input.focus();

      const onApply = ()=>{
        const fontSize = parseFloat(size.value) || 24;
        const pt = this.clientToSVG(clientX,clientY);
        if(input.value.trim()) this.createText(pt.x,pt.y,input.value,fontSize);
        cleanup();
      };
      const onCancel = ()=>{cleanup()};
      const cleanup = ()=>{dialog.classList.remove('active'); apply.removeEventListener('click',onApply); cancel.removeEventListener('click',onCancel); input.value='';};
      apply.addEventListener('click', onApply);
      cancel.addEventListener('click', onCancel);
    }

    createText(x,y,text,fontSize){
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', x);
      t.setAttribute('y', y);
      t.setAttribute('font-size', fontSize);
      t.setAttribute('fill', document.getElementById('fill-color').value);
      t.setAttribute('opacity', document.getElementById('opacity').value);
      t.textContent = text;
      t.addEventListener('mousedown', (e)=>{e.stopPropagation(); this.selectElement(t);});
      this.getActiveLayerGroup().appendChild(t);
    }

    // --- selection ---
    selectAtPoint(clientX,clientY){
      // use elementFromPoint to detect topmost element at screen coords
      const el = document.elementFromPoint(clientX, clientY);
      if(!el) return;
      // make sure it's inside our svg content
      if(this.svgContent.contains(el) || el === this.canvas || this.canvas.contains(el)){
        // find the nearest svg graphics element (rect,circle,path,text)
        let candidate = el;
        while(candidate && candidate !== this.svgContent){
          const tag = candidate.tagName && candidate.tagName.toLowerCase();
          if(['rect','circle','path','text','image','g'].includes(tag)){
            if(candidate === this.svgContent) break;
            this.selectElement(candidate);
            return;
          }
          candidate = candidate.parentNode;
        }
        // if no candidate found, deselect
        this.clearSelection();
      }
    }

    selectElement(element){
      this.clearSelection();
      element.classList.add('selected');
      // bring visual focus
      element.setAttribute('stroke', element.getAttribute('stroke') || '#000');
      // populate property controls
      if(element.hasAttribute('fill')) document.getElementById('fill-color').value = this.normalizeColor(element.getAttribute('fill'));
      if(element.hasAttribute('stroke')) document.getElementById('stroke-color').value = this.normalizeColor(element.getAttribute('stroke'));
      if(element.hasAttribute('stroke-width')) document.getElementById('stroke-width').value = element.getAttribute('stroke-width');
      if(element.hasAttribute('opacity')) document.getElementById('opacity').value = element.getAttribute('opacity');
    }

    clearSelection(){
      document.querySelectorAll('.selected').forEach(s=>s.classList.remove('selected'));
    }

    normalizeColor(c){
      // basic normalization for #rrggbb and rgb() -> returns hex when possible
      if(!c) return '#000000';
      if(c.startsWith('#')) return c;
      // rgb(r,g,b)
      const m = c.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if(m) return '#'+[1,2,3].map(i=>Number(m[i]).toString(16).padStart(2,'0')).join('');
      return c;
    }

    updateSelectedElement(){
      const sel = document.querySelector('.selected');
      if(!sel) return;
      if(sel.hasAttribute('fill')) sel.setAttribute('fill', document.getElementById('fill-color').value);
      if(sel.hasAttribute('stroke')) sel.setAttribute('stroke', document.getElementById('stroke-color').value);
      if(sel.hasAttribute('stroke-width')) sel.setAttribute('stroke-width', document.getElementById('stroke-width').value);
      if(sel.hasAttribute('opacity')) sel.setAttribute('opacity', document.getElementById('opacity').value);
    }

    // --- layers ---
    getActiveLayerGroup(){
      const id = this.layers[this.activeLayer];
      const g = document.getElementById(id);
      if(g) return g;
      // fallback to svg-content
      return this.svgContent;
    }

    addLayer(){
      const layerId = `layer-${this.layers.length+1}`;
      const layer = document.createElementNS('http://www.w3.org/2000/svg','g');
      layer.setAttribute('id', layerId);
      layer.setAttribute('data-name', `Layer ${this.layers.length+1}`);
      this.svgContent.appendChild(layer);
      this.layers.push(layerId);

      const layersList = document.getElementById('layers-list');
      const layerItem = document.createElement('div');
      layerItem.className = 'layer-item';
      layerItem.innerHTML = `<span>Layer ${this.layers.length}</span><button class="delete-layer">×</button>`;
      layerItem.querySelector('.delete-layer').addEventListener('click',(e)=>{e.stopPropagation(); this.deleteLayer(layerId, layerItem);});
      layerItem.addEventListener('click', ()=>{document.querySelectorAll('.layer-item').forEach(it=>it.classList.remove('active')); layerItem.classList.add('active'); this.activeLayer = this.layers.indexOf(layerId);});
      layersList.appendChild(layerItem);
      // auto-activate the new layer
      document.querySelectorAll('.layer-item').forEach(it=>it.classList.remove('active'));
      layerItem.classList.add('active');
      this.activeLayer = this.layers.length - 1;
    }

    deleteLayer(layerId, layerItem){
      const idx = this.layers.indexOf(layerId);
      if(idx === -1) return;
      // remove SVG group and UI
      const g = document.getElementById(layerId);
      if(g) g.remove();
      this.layers.splice(idx,1);
      layerItem.remove();
      // select previous layer
      this.activeLayer = Math.max(0, idx-1);
      const items = document.querySelectorAll('.layer-item');
      if(items[this.activeLayer]) items[this.activeLayer].classList.add('active');
    }

    // --- project save/load/export ---
    serializeProject(){
      // capture essential info
      const svgRoot = document.getElementById('main-canvas');
      const data = {
        width: svgRoot.getAttribute('width'),
        height: svgRoot.getAttribute('height'),
        viewBox: svgRoot.getAttribute('viewBox'),
        svgContent: this.svgContent.innerHTML,
        layers: this.layers,
        activeLayer: this.activeLayer
      };
      return JSON.stringify(data);
    }

    saveProject(){
      const json = this.serializeProject();
      // save to localStorage
      localStorage.setItem('inkrealm_project', json);
      // download file
      const blob = new Blob([json], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `inkrealm-project-${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.json`;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      alert('Project saved to localStorage and downloaded as JSON.');
    }

    loadFromFile(e){
      const f = e.target.files[0];
      if(!f) return;
      const reader = new FileReader();
      reader.onload = ()=>{
        try{
          const data = JSON.parse(reader.result);
          this.loadProjectObject(data);
        }catch(err){alert('Invalid project file');}
      };
      reader.readAsText(f);
      e.target.value = '';
    }

    loadProjectObject(data){
      const svgRoot = document.getElementById('main-canvas');
      if(data.viewBox) svgRoot.setAttribute('viewBox', data.viewBox);
      if(data.width) svgRoot.setAttribute('width', data.width);
      if(data.height) svgRoot.setAttribute('height', data.height);
      this.svgContent.innerHTML = data.svgContent || '';
      this.layers = data.layers || Array.from(this.svgContent.children).map(c=>c.id || c.getAttribute('id'));
      this.activeLayer = data.activeLayer || 0;
      // rebuild layer UI
      const layersList = document.getElementById('layers-list'); layersList.innerHTML = '';
      this.layers.forEach((id, idx)=>{
        const item = document.createElement('div'); item.className = 'layer-item'; item.innerHTML = `<span>Layer ${idx+1}</span><button class="delete-layer">×</button>`;
        item.querySelector('.delete-layer').addEventListener('click',(e)=>{e.stopPropagation(); this.deleteLayer(id,item);});
        item.addEventListener('click', ()=>{document.querySelectorAll('.layer-item').forEach(it=>it.classList.remove('active')); item.classList.add('active'); this.activeLayer = idx;});
        layersList.appendChild(item);
        if(idx === this.activeLayer) item.classList.add('active');
      });
      alert('Project loaded');
    }

    restoreIfAny(){
      const existing = localStorage.getItem('inkrealm_project');
      if(existing){
        try{const data = JSON.parse(existing); this.loadProjectObject(data);}catch(e){/* ignore */}
      }
    }

    exportPNGAndSVG(){
      const svgRoot = document.getElementById('main-canvas');
      // export SVG
      const serializer = new XMLSerializer();
      const source = '<?xml version="1.0" standalone="no"?>\n' + serializer.serializeToString(svgRoot);
      const svgBlob = new Blob([source], {type:'image/svg+xml;charset=utf-8'});
      const url = URL.createObjectURL(svgBlob);
      // download svg file
      const a = document.createElement('a'); a.href = url; a.download = 'inkrealm-export.svg'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);

      // PNG export via canvas
      const svgData = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(source)));
      const img = new Image();
      img.onload = ()=>{
        const canvas = document.createElement('canvas');
        canvas.width = svgRoot.viewBox.baseVal.width || svgRoot.clientWidth;
        canvas.height = svgRoot.viewBox.baseVal.height || svgRoot.clientHeight;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = getComputedStyle(document.body).backgroundColor || '#ffffff';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(img,0,0,canvas.width,canvas.height);
        canvas.toBlob((blob)=>{
          const url2 = URL.createObjectURL(blob);
          const a2 = document.createElement('a'); a2.href = url2; a2.download = 'inkrealm-export.png'; document.body.appendChild(a2); a2.click(); a2.remove(); URL.revokeObjectURL(url2);
        });
      };
      img.onerror = ()=>{console.warn('PNG export failed');};
      img.src = svgData;
    }

    newProject(){
      if(!confirm('Create a new project? Unsaved changes will be lost.')) return;
      this.svgContent.innerHTML = '';
      this.layers = [];
      document.getElementById('layers-list').innerHTML = '';
      this.addLayer();
    }
  }

  // initialize
  window.addEventListener('DOMContentLoaded', ()=>{window.inkRealm = new InkRealmSVG();

    // --- Font system: Google Fonts + custom uploads + convert-to-paths using opentype.js ---
    const opentypeScript = document.createElement('script');
    opentypeScript.src = 'https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js';
    opentypeScript.onload = ()=>{ console.log('opentype.js loaded'); };
    document.head.appendChild(opentypeScript);

    const fontSelect = document.getElementById('font-select');
    const addGoogleFont = document.getElementById('add-google-font');
    const uploadBtn = document.getElementById('upload-font-btn');
    const uploadInput = document.getElementById('upload-font');
    const convertBtn = document.getElementById('convert-text');

    // helper: inject Google Fonts CSS link
    function injectGoogleFontLink(family){
      const id = 'gf-' + family.replace(/[^a-z0-9]+/gi,'');
      if(document.getElementById(id)) return;
      const link = document.createElement('link');
      link.id = id;
      link.rel = 'stylesheet';
      link.href = `https://fonts.googleapis.com/css2?family=${family}&display=swap`;
      document.head.appendChild(link);
    }

    // try to fetch the actual font file url from Google Fonts CSS; may be blocked by CORS in some browsers
    async function fetchGoogleFontArrayBuffer(family){
      try{
        const cssUrl = `https://fonts.googleapis.com/css2?family=${family}&display=swap`;
        const cssRes = await fetch(cssUrl);
        if(!cssRes.ok) throw new Error('Failed to fetch font CSS');
        const cssText = await cssRes.text();
        const urlMatch = cssText.match(/src: url\((https:[^)]+)\) format\('woff2'\)/);
        const url = urlMatch ? urlMatch[1] : null;
        if(!url) throw new Error('Could not find woff2 URL');
        // fetch the font file
        const fontRes = await fetch(url);
        if(!fontRes.ok) throw new Error('Failed to fetch font file');
        const ab = await fontRes.arrayBuffer();
        return ab;
      }catch(err){
        console.warn('Google font fetch failed, fallback to upload', err);
        return null;
      }
    }

    // maintain a map of loaded custom fonts (ArrayBuffer) or already-injected families
    window.loadedFonts = window.loadedFonts || {};

    fontSelect.addEventListener('change', async (e)=>{
      const family = e.target.value;
      if(!family) return;
      injectGoogleFontLink(family);
      // attempt to prefetch the file (best-effort)
      const ab = await fetchGoogleFontArrayBuffer(family);
      if(ab) window.loadedFonts[family] = ab;
    });

    addGoogleFont.addEventListener('change', (e)=>{
      const v = e.target.value.trim();
      if(!v) return;
      injectGoogleFontLink(v);
      // add to select for convenience
      const opt = document.createElement('option'); opt.value = v; opt.textContent = v.replace(/\+/g,' ');
      fontSelect.appendChild(opt); fontSelect.value = v; e.target.value = '';
    });

    uploadBtn.addEventListener('click', ()=>uploadInput.click());
    uploadInput.addEventListener('change', async (e)=>{
      const f = e.target.files[0];
      if(!f) return;
      const ab = await f.arrayBuffer();
      window.loadedFonts[f.name] = ab;
      alert(`Font ${f.name} loaded — you can now select text and convert to paths using this font.`);
      e.target.value = '';
    });

    // Convert selected text elements to paths
    convertBtn.addEventListener('click', async ()=>{
      // find selected text elements; if none, convert all text nodes
      const selected = document.querySelectorAll('.selected');
      const textEls = selected.length ? Array.from(selected).filter(s=>s.tagName === 'text') : Array.from(document.querySelectorAll('#svg-content text'));
      if(textEls.length === 0){ alert('No text found or selected to convert.'); return; }

      // ensure opentype is loaded
      if(typeof opentype === 'undefined'){ alert('opentype.js is not loaded yet. Please wait a moment and try again.'); return; }

      for(const t of textEls){
        try{
          const fontFamily = (t.getAttribute('font-family') || getComputedStyle(t).fontFamily || '').split(',')[0].replace(/['\"]+/g,'').trim();
          const fontSize = parseFloat(t.getAttribute('font-size') || getComputedStyle(t).fontSize || 24);
          const x = parseFloat(t.getAttribute('x') || 0);
          const y = parseFloat(t.getAttribute('y') || 0);
          const text = t.textContent;

          let fontBuffer = null;
          // check loadedFonts by family or by uploaded filename
          if(window.loadedFonts[fontFamily]) fontBuffer = window.loadedFonts[fontFamily];
          // attempt to fetch Google font file if not already
          if(!fontBuffer && fontSelect.value){
            const ab = await fetchGoogleFontArrayBuffer(fontSelect.value);
            if(ab){ fontBuffer = ab; window.loadedFonts[fontSelect.value] = ab; }
          }

          if(!fontBuffer){
            // fallback: ask the user to upload a font for this family
            if(!confirm(`Font file for "${fontFamily || 'unknown'}" not found or blocked.
Would you like to upload a font file (TTF/OTF/WOFF)?`)) continue;
            uploadInput.click();
            // wait for user upload (best-effort: we stop this conversion loop)
            return;
          }

          const font = opentype.parse(fontBuffer);
          const path = font.getPath(text, x, y, fontSize);
          const d = path.toPathData(2);
          const p = document.createElementNS('http://www.w3.org/2000/svg','path');
          p.setAttribute('d', d);
          p.setAttribute('fill', t.getAttribute('fill') || '#000');
          p.setAttribute('opacity', t.getAttribute('opacity') || 1);
          p.setAttribute('stroke', t.getAttribute('stroke') || 'none');
          p.setAttribute('stroke-width', t.getAttribute('stroke-width') || 0);

          // replace text with path
          const parent = t.parentNode;
          parent.insertBefore(p, t);
          t.remove();
        }catch(err){
          console.error('Conversion error', err);
          alert('Failed to convert some text to paths. See console for details.');
        }
      }
      alert('Conversion complete. Text converted to paths.');
    });

  });
  </script>
  <!-- Font Manager Modal -->
  <div id="fontManagerModal" class="dialog" style="display:none;align-items:flex-start;padding-top:4rem">
    <div class="dialog-content" style="min-width:360px;max-width:640px;">
      <h3>Font Manager</h3>
      <p style="font-size:0.9rem;color:var(--text-secondary)">Manage Google fonts and uploaded font files. Uploaded fonts are stored locally in your browser.</p>
      <div style="display:flex;gap:.5rem;flex-wrap:wrap;margin-top:.5rem">
        <input id="fm-upload" type="file" accept=".ttf,.otf,.woff,.woff2" style="display:none">
        <button id="fm-upload-btn" class="btn">Upload Font</button>
        <button id="fm-clear" class="btn btn-secondary">Clear All Uploaded Fonts</button>
        <button id="fm-close" class="btn btn-secondary">Close</button>
      </div>

      <div id="fm-list" style="margin-top:1rem;max-height:40vh;overflow:auto;border-top:1px solid var(--border-color);padding-top:1rem"></div>
    </div>
  </div>

  <!-- Slide-out Help Menu -->
  <div id="helpPanel" class="fixed top-0 right-0 w-80 h-full bg-gray-900 text-white shadow-2xl transform translate-x-full transition-transform duration-300 p-4 z-50 overflow-y-auto">
    <h2 class="text-xl font-bold mb-4">InkRealm SVG Editor — Help</h2>
    <p class="mb-4">Welcome! Here’s a quick guide to using the editor:</p>
    <ul class="list-disc pl-5 space-y-2">
      <li><strong>Select Tool:</strong> Choose Select to click elements.</li>
      <li><strong>Shapes:</strong> Draw rectangles, circles, lines, paths.</li>
      <li><strong>Layers:</strong> Add and organize visual layers.</li>
      <li><strong>Path Editing:</strong> Use the Node tool (N) to edit path points.</li>
      <li><strong>Export:</strong> Save SVG, PNG, or a full project file.</li>
    </ul>
  </div>

  <button id="helpToggle" class="fixed top-4 right-4 bg-blue-600 text-white px-3 py-2 rounded shadow z-50">Help</button>

<script>
// Slide-out help panel
const helpToggle = document.getElementById('helpToggle');

// --- Full Font Manager Logic ---
(function(){
  const fmShow = document.getElementById('show-font-list');
  const fmClearBtn = document.getElementById('clear-font-cache');
  const fmModal = document.getElementById('fontManagerModal');
  const fmClose = document.getElementById('fm-close');
  const fmUploadBtn = document.getElementById('fm-upload-btn');
  const fmUploadInput = document.getElementById('fm-upload');
  const fmList = document.getElementById('fm-list');

  // font registry persisted in localStorage
  window.fontRegistry = JSON.parse(localStorage.getItem('inkrealm_fonts') || '[]');
  window.loadedFonts = window.loadedFonts || {};

  function saveRegistry(){ localStorage.setItem('inkrealm_fonts', JSON.stringify(window.fontRegistry)); }

  // base64 helpers
  function abToBase64(ab){ const bytes = new Uint8Array(ab); let bin=''; const chunk=8192; for(let i=0;i<bytes.length;i+=chunk){ bin += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk)); } return btoa(bin); }
  function base64ToAB(b64){ const bin = atob(b64); const len = bin.length; const ab = new Uint8Array(len); for(let i=0;i<len;i++) ab[i]=bin.charCodeAt(i); return ab.buffer; }

  function registerUploadedFont(name, arrayBuffer){
    const id = 'u-' + Date.now() + '-' + Math.random().toString(36).slice(2,8);
    const b64 = abToBase64(arrayBuffer);
    const entry = { id, name, source: 'uploaded', b64 };
    window.fontRegistry.push(entry);
    // store in loadedFonts map for immediate use
    window.loadedFonts[name] = arrayBuffer;
    saveRegistry();
    renderList();
    injectUploadedFontCSS(entry);
  }

  function injectUploadedFontCSS(entry){
    try{
      const fontName = entry.name.replace(/\.[^/.]+$/, '');
      const ab = base64ToAB(entry.b64);
      const blob = new Blob([ab], { type: 'font/woff2' });
      const url = URL.createObjectURL(blob);
      const styleId = 'fm-font-' + entry.id;
      if(document.getElementById(styleId)) return;
      const style = document.createElement('style');
      style.id = styleId;
      style.textContent = `@font-face { font-family: "${fontName}"; src: url('${url}'); }`;
      document.head.appendChild(style);
      // ensure loadedFonts map contains ArrayBuffer
      window.loadedFonts[fontName] = ab;
    }catch(err){ console.warn('inject font css failed', err); }
  }

  function renderList(){
    fmList.innerHTML = '';
    if(window.fontRegistry.length === 0) fmList.innerHTML = '<p style="color:var(--text-secondary)">No uploaded fonts yet.</p>';
    window.fontRegistry.forEach(entry=>{
      const row = document.createElement('div');
      row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center'; row.style.padding='6px 0'; row.style.borderBottom='1px solid var(--border-color)';
      const left = document.createElement('div');
      left.innerHTML = `<div style=\"font-weight:600\">${entry.name}</div><div style=\"font-size:12px;color:var(--text-secondary)\">${entry.source}</div>`;
      const right = document.createElement('div');
      const preview = document.createElement('div'); preview.textContent = 'Abg'; preview.style.fontFamily = entry.name.replace(/\.[^/.]+$/, ''); preview.style.padding='6px'; preview.style.border='1px solid var(--border-color)'; preview.style.marginRight='8px'; preview.style.display='inline-block';
      const btnDownload = document.createElement('button'); btnDownload.className='btn'; btnDownload.textContent='Download';
      const btnRemove = document.createElement('button'); btnRemove.className='btn btn-secondary'; btnRemove.textContent='Remove';
      btnDownload.addEventListener('click', ()=>{
        const ab = base64ToAB(entry.b64);
        const blob = new Blob([ab], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download = entry.name; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      });
      btnRemove.addEventListener('click', ()=>{
        if(!confirm('Remove this uploaded font?')) return;
        window.fontRegistry = window.fontRegistry.filter(e=>e.id!==entry.id);
        // remove style tag
        const styleTag = document.getElementById('fm-font-' + entry.id); if(styleTag) styleTag.remove();
        saveRegistry(); renderList();
      });
      right.appendChild(preview); right.appendChild(btnDownload); right.appendChild(btnRemove);
      row.appendChild(left); row.appendChild(right); fmList.appendChild(row);
    });
  }

  // wire UI
  fmShow.addEventListener('click', ()=>{ fmModal.style.display='flex'; renderList(); });
  fmClose.addEventListener('click', ()=>{ fmModal.style.display='none'; });
  fmClearBtn.addEventListener('click', ()=>{ if(!confirm('Clear all uploaded fonts?')) return; window.fontRegistry=[]; saveRegistry(); // remove style tags
    document.querySelectorAll('[id^="fm-font-"]').forEach(n=>n.remove()); renderList(); alert('Cleared uploaded fonts'); });

  fmUploadBtn.addEventListener('click', ()=>fmUploadInput.click());
  fmUploadInput.addEventListener('change', async (e)=>{ const f = e.target.files[0]; if(!f) return; const ab = await f.arrayBuffer(); registerUploadedFont(f.name, ab); e.target.value=''; alert('Font uploaded and registered.'); });

  // on load, re-inject uploaded fonts
  window.fontRegistry.forEach(injectUploadedFontCSS);

})();

// Slide-out help panel
const helpToggle = document.getElementById('helpToggle');
const helpPanel = document.getElementById('helpPanel');
helpToggle.addEventListener('click', () => {
  helpPanel.classList.toggle('translate-x-full');
});

// --- Node-Level Path Editing (Initial Implementation) ---
// Adds draggable anchors to path nodes and allows repositioning.
class PathEditor {
  constructor(svg) {
    this.svg = svg;
    this.activePath = null;
    this.anchorPoints = [];
  }

  enableFor(pathElement) {
    this.clear();
    this.activePath = pathElement;

    const pathLen = pathElement.getTotalLength();
    const points = [];
    for (let t = 0; t <= 1; t += 0.1) {
      points.push(pathElement.getPointAtLength(pathLen * t));
    }
    
    points.forEach((pt, index) => {
      const anchor = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      anchor.setAttribute('cx', pt.x);
      anchor.setAttribute('cy', pt.y);
      anchor.setAttribute('r', 6);
      anchor.setAttribute('fill', 'white');
      anchor.setAttribute('stroke', 'blue');
      anchor.style.cursor = 'pointer';
      anchor.dataset.index = index;

      this.svg.appendChild(anchor);
      this.anchorPoints.push(anchor);

      // Drag to modify path
      let dragging = false;
      anchor.addEventListener('mousedown', () => dragging = true);
      window.addEventListener('mouseup', () => dragging = false);
      window.addEventListener('mousemove', (evt) => {
        if (!dragging) return;
        const pt = this.getSVGPoint(evt);
        anchor.setAttribute('cx', pt.x);
        anchor.setAttribute('cy', pt.y);
        this.updatePathFromAnchors();
      });
    });
  }

  getSVGPoint(evt) {
    const pt = this.svg.createSVGPoint();
    pt.x = evt.clientX;
    pt.y = evt.clientY;
    return pt.matrixTransform(this.svg.getScreenCTM().inverse());
  }

  updatePathFromAnchors() {
    if (!this.activePath) return;
    const d = this.anchorPoints.map((a, i) => `${i === 0 ? 'M' : 'L'} ${a.getAttribute('cx')} ${a.getAttribute('cy')}`).join(' ');
    this.activePath.setAttribute('d', d);
  }

  clear() {
    this.anchorPoints.forEach(a => a.remove());
    this.anchorPoints = [];
    this.activePath = null;
  }
}

// Integrate PathEditor into Main App if tool mode is 'node'
window.addEventListener('DOMContentLoaded',()=>{
  if (window.app && window.app.svgCanvas) {
    window.app.pathEditor = new PathEditor(window.app.svgCanvas);

    const originalSelectElement = app.selectElement.bind(app);
    app.selectElement = function(el) {
      originalSelectElement(el);
      if (el && el.tagName === 'path' && this.currentTool === 'node') {
        this.pathEditor.enableFor(el);
      } else {
        this.pathEditor.clear();
      }
    }
  }
});
</script>
</body>
</html>
