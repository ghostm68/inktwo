<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Free, open SVG logo editor with text-to-path, Google Fonts, custom font upload, and full vector editing.">
  <meta name="keywords" content="free svg editor, logo maker, vector editor, svg path editor, text to svg, google fonts svg, open source logo tool">
  <meta name="og:title" content="InkRealm — Free SVG Logo Editor">
  <meta name="og:description" content="Create, edit, and export SVG logos without tricks, paywalls, or AI traps.">
  <meta name="og:type" content="website">
  <meta name="robots" content="index, follow">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <link rel="icon" href="/svg/favicon.svg" type="image/svg+xml">
  <link rel="alternate icon" href="/svg/favicon.png" type="image/png">

  <!-- Google Fonts - Curated Selection -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Open+Sans:wght@400;700&family=Lato:wght@400;700&family=Montserrat:wght@400;700&family=Oswald:wght@400;700&family=Raleway:wght@400;700&family=Playfair+Display:wght@400;700&family=Merriweather:wght@400;700&family=PT+Sans:wght@400;700&family=Nunito:wght@400;700&family=Poppins:wght@400;700&family=Ubuntu:wght@400;700&family=Lobster&family=Pacifico&family=Righteous&family=Bebas+Neue&family=Abril+Fatface&family=Permanent+Marker&family=Dancing+Script:wght@400;700&family=Indie+Flower&family=Caveat:wght@400;700&family=Shadows+Into+Light&family=Architects+Daughter&family=Amatic+SC:wght@400;700&family=Press+Start+2P&family=VT323&family=Inconsolata:wght@400;700&family=Fira+Code:wght@400;700&family=Source+Code+Pro:wght@400;700&family=IBM+Plex+Mono:wght@400;700&family=Cinzel:wght@400;700&family=Cormorant+Garamond:wght@400;700&family=EB+Garamond:wght@400;700&family=Libre+Baskerville:wght@400;700&family=Crimson+Text:wght@400;700&family=Anton&family=Fjalla+One&family=Russo+One&family=Alfa+Slab+One&family=Bungee&family=Bangers&family=Staatliches&family=Teko:wght@400;700&family=Barlow+Condensed:wght@400;700&family=Comfortaa:wght@400;700&family=Quicksand:wght@400;700&family=Karla:wght@400;700&family=Work+Sans:wght@400;700&display=swap" rel="stylesheet">

  <title>SVG DESIGN — InkRealm</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      display: flex;
      height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: #1e1e1e;
      color: #e0e0e0;
      font-size: 11px;
      overflow: hidden;
    }
    .sidebar {
      width: 240px;
      background: #2a2a2a;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      border-right: 1px solid #333;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    h2, h3 {
      margin: 0 0 3px 0;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #aaa;
      border-bottom: 1px solid #444;
      padding-bottom: 3px;
      margin-top: 8px;
    }
    h2:first-child { margin-top: 0; }
    
    button, select, input[type="number"], input[type="text"], input[type="file"] {
      width: 100%;
      padding: 5px 6px;
      background: #3b3b3b;
      color: #fff;
      border: 1px solid #555;
      border-radius: 3px;
      font-size: 11px;
      box-sizing: border-box;
    }
    button:hover {
      background: #4a4a4a;
      cursor: pointer;
      border-color: #777;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    input[type="color"] {
      width: 100%;
      height: 26px;
      padding: 0;
      border: none;
      background: none;
      cursor: pointer;
    }
    .row {
      display: flex;
      gap: 4px;
      align-items: center;
    }
    label { 
      font-size: 10px; 
      color: #999; 
      margin-top: 2px;
      display: block;
    }
    
    #canvas-container {
      flex: 1;
      background: #111;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }
    svg {
      width: 88%;
      height: 88%;
      background: #fff;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
    
    .selected-outline {
      outline: 2px dashed #4a9eff;
      outline-offset: 2px;
    }
    
    #history-info {
      font-size: 9px;
      color: #666;
      text-align: center;
      padding: 2px;
    }
    
    .btn-danger {
      background: #5a2a2a !important;
      border-color: #7a3a3a !important;
    }
    .btn-success {
      background: #2a5a2a !important;
      border-color: #3a7a3a !important;
      font-weight: bold;
      padding: 8px !important;
    }
    .btn-primary {
      background: #2a3a5a !important;
      border-color: #3a4a7a !important;
    }
  </style>
</head>
<body>

<div class="sidebar">
  <h2>Canvas</h2>
  <select id="canvasPreset" onchange="setCanvasSize()">
    <option value="800,600">Default (800×600)</option>
    <option value="512,512">Square Logo (512×512)</option>
    <option value="1024,1024">Large Square (1024×1024)</option>
    <option value="1200,630">Social Banner (1200×630)</option>
    <option value="1920,1080">HD (1920×1080)</option>
  </select>

  <h3>Actions</h3>
  <button onclick="downloadSVG()" class="btn-success">Download SVG</button>
  <div class="row">
    <button onclick="deleteSelected()" class="btn-danger">Delete</button>
    <button onclick="importSVG()" class="btn-primary">Import</button>
  </div>
  <input type="file" id="svgFileInput" accept=".svg" style="display:none;" onchange="handleSVGUpload(event)" />

  <h3>History</h3>
  <div class="row">
    <button onclick="undo()" id="undoBtn">Undo</button>
    <button onclick="redo()" id="redoBtn">Redo</button>
  </div>
  <div id="history-info">No history yet</div>

  <h3>Tools</h3>
  <button onclick="setTool('select')">Select / Move</button>
  <div class="row">
    <button onclick="setTool('rect')">Rect</button>
    <button onclick="setTool('circle')">Circle</button>
  </div>
  <div class="row">
    <button onclick="setTool('path')">Path</button>
    <button onclick="setTool('text')">Text</button>
  </div>

  <h3>Style</h3>
  <label>Fill Color</label>
  <input type="color" id="fillColor" value="#000000" />
  
  <label>Stroke Color</label>
  <input type="color" id="strokeColor" value="#000000" />
  
  <label>Stroke Width</label>
  <input type="number" id="strokeWidth" min="0" max="20" value="2" />

  <h3>Typography</h3>
  <select id="fontSelect" onchange="updateSelectedFont()">
    <optgroup label="System Fonts">
      <option value="Arial">Arial</option>
      <option value="Verdana">Verdana</option>
      <option value="Georgia">Georgia</option>
      <option value="Times New Roman">Times New Roman</option>
      <option value="Courier New">Courier New</option>
      <option value="Trebuchet MS">Trebuchet MS</option>
      <option value="Impact">Impact</option>
      <option value="Comic Sans MS">Comic Sans MS</option>
      <option value="Palatino Linotype">Palatino Linotype</option>
      <option value="Lucida Console">Lucida Console</option>
      <option value="Century Gothic">Century Gothic</option>
      <option value="Garamond">Garamond</option>
      <option value="Book Antiqua">Book Antiqua</option>
    </optgroup>
    <optgroup label="Sans-Serif — Modern">
      <option value="Roboto">Roboto</option>
      <option value="Open Sans">Open Sans</option>
      <option value="Lato">Lato</option>
      <option value="Montserrat">Montserrat</option>
      <option value="Oswald">Oswald</option>
      <option value="Raleway">Raleway</option>
      <option value="PT Sans">PT Sans</option>
      <option value="Nunito">Nunito</option>
      <option value="Poppins">Poppins</option>
      <option value="Ubuntu">Ubuntu</option>
      <option value="Work Sans">Work Sans</option>
      <option value="Karla">Karla</option>
    </optgroup>
    <optgroup label="Serif — Classic">
      <option value="Playfair Display">Playfair Display</option>
      <option value="Merriweather">Merriweather</option>
      <option value="Cinzel">Cinzel</option>
      <option value="Cormorant Garamond">Cormorant Garamond</option>
      <option value="EB Garamond">EB Garamond</option>
      <option value="Libre Baskerville">Libre Baskerville</option>
      <option value="Crimson Text">Crimson Text</option>
    </optgroup>
    <optgroup label="Display — Bold">
      <option value="Anton">Anton</option>
      <option value="Fjalla One">Fjalla One</option>
      <option value="Russo One">Russo One</option>
      <option value="Alfa Slab One">Alfa Slab One</option>
      <option value="Bebas Neue">Bebas Neue</option>
      <option value="Righteous">Righteous</option>
      <option value="Bungee">Bungee</option>
      <option value="Bangers">Bangers</option>
      <option value="Staatliches">Staatliches</option>
      <option value="Teko">Teko</option>
      <option value="Barlow Condensed">Barlow Condensed</option>
      <option value="Abril Fatface">Abril Fatface</option>
    </optgroup>
    <optgroup label="Handwriting">
      <option value="Lobster">Lobster</option>
      <option value="Pacifico">Pacifico</option>
      <option value="Permanent Marker">Permanent Marker</option>
      <option value="Dancing Script">Dancing Script</option>
      <option value="Indie Flower">Indie Flower</option>
      <option value="Caveat">Caveat</option>
      <option value="Shadows Into Light">Shadows Into Light</option>
      <option value="Architects Daughter">Architects Daughter</option>
      <option value="Amatic SC">Amatic SC</option>
    </optgroup>
    <optgroup label="Monospace — Code">
      <option value="Courier New">Courier New</option>
      <option value="Inconsolata">Inconsolata</option>
      <option value="Fira Code">Fira Code</option>
      <option value="Source Code Pro">Source Code Pro</option>
      <option value="IBM Plex Mono">IBM Plex Mono</option>
      <option value="VT323">VT323</option>
      <option value="Press Start 2P">Press Start 2P</option>
    </optgroup>
    <optgroup label="Rounded — Friendly">
      <option value="Comfortaa">Comfortaa</option>
      <option value="Quicksand">Quicksand</option>
    </optgroup>
  </select>
  
  <label>Font Size</label>
  <input type="number" id="fontSize" min="8" max="200" value="32" onchange="updateSelectedFontSize()" />

  <h3>Advanced</h3>
  <button onclick="convertTextToPath()" class="btn-primary">Convert Text → Path</button>
  <label style="font-size: 9px; color: #777; margin-top: -3px;">Select text first, then click</label>
</div>

<div id="canvas-container">
  <svg id="svgCanvas" width="800" height="600" viewBox="0 0 800 600"></svg>
</div>

<script>
// === CORE STATE ===
let tool = "select";
let svg = document.getElementById("svgCanvas");
let isDrawing = false;
let currentElement = null;
let startX, startY;
let selectedElement = null;
let offset = { x: 0, y: 0 };

// === HISTORY MANAGEMENT ===
let history = [];
let historyIndex = -1;
const MAX_HISTORY = 50;

function saveState() {
  // Remove any redo states
  history = history.slice(0, historyIndex + 1);
  
  // Save current state
  history.push(svg.innerHTML);
  
  // Limit history size
  if (history.length > MAX_HISTORY) {
    history.shift();
  } else {
    historyIndex++;
  }
  
  updateHistoryUI();
}

function undo() {
  if (historyIndex > 0) {
    historyIndex--;
    svg.innerHTML = history[historyIndex];
    selectedElement = null;
    updateHistoryUI();
  }
}

function redo() {
  if (historyIndex < history.length - 1) {
    historyIndex++;
    svg.innerHTML = history[historyIndex];
    selectedElement = null;
    updateHistoryUI();
  }
}

function updateHistoryUI() {
  document.getElementById('undoBtn').disabled = historyIndex <= 0;
  document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
  document.getElementById('history-info').textContent = 
    `Step ${historyIndex + 1} of ${history.length}`;
}

// === TOOL FUNCTIONS ===
function setTool(t) {
  tool = t;
  selectedElement = null;
  document.querySelectorAll('.sidebar button').forEach(b => {
    b.style.boxShadow = 'none';
  });
}

function deleteSelected() {
  if(selectedElement) {
    saveState();
    selectedElement.remove();
    selectedElement = null;
  }
}

function updateSelectedFont() {
  if(selectedElement && selectedElement.tagName === 'text') {
    selectedElement.setAttribute('font-family', document.getElementById('fontSelect').value);
  }
}

function updateSelectedFontSize() {
  if(selectedElement && selectedElement.tagName === 'text') {
    selectedElement.setAttribute('font-size', document.getElementById('fontSize').value);
  }
}

// === CANVAS SIZE ===
function setCanvasSize() {
  let preset = document.getElementById('canvasPreset').value.split(',');
  let w = preset[0], h = preset[1];
  svg.setAttribute('width', w);
  svg.setAttribute('height', h);
  svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
}

// === TEXT TO PATH (Basic Implementation) ===
function convertTextToPath() {
  if(!selectedElement || selectedElement.tagName !== 'text') {
    alert('Please select a text element first');
    return;
  }
  
  // Get text properties
  let text = selectedElement.textContent;
  let x = parseFloat(selectedElement.getAttribute('x'));
  let y = parseFloat(selectedElement.getAttribute('y'));
  let fontSize = selectedElement.getAttribute('font-size') || 32;
  let fontFamily = selectedElement.getAttribute('font-family') || 'Arial';
  let fill = selectedElement.getAttribute('fill') || '#000000';
  let stroke = selectedElement.getAttribute('stroke') || 'none';
  let strokeWidth = selectedElement.getAttribute('stroke-width') || 0;
  
  // Create temporary canvas
  let canvas = document.createElement('canvas');
  let ctx = canvas.getContext('2d');
  ctx.font = `${fontSize}px "${fontFamily}"`;
  
  // Measure text
  let metrics = ctx.measureText(text);
  let width = metrics.width;
  
  canvas.width = width + 20;
  canvas.height = fontSize * 1.5;
  
  // Draw text on canvas
  ctx.font = `${fontSize}px "${fontFamily}"`;
  ctx.fillStyle = fill;
  ctx.textBaseline = 'top';
  ctx.fillText(text, 10, 10);
  
  // Get image data
  let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  
  // Simple path tracing (this is a simplified version)
  // For production, you'd want to use a library like opentype.js
  let pathData = tracePath(imageData, canvas.width, canvas.height);
  
  if(pathData) {
    saveState();
    
    // Create new path element
    let pathElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathElem.setAttribute("d", pathData);
    pathElem.setAttribute("fill", fill);
    pathElem.setAttribute("stroke", stroke);
    pathElem.setAttribute("stroke-width", strokeWidth);
    pathElem.setAttribute("transform", `translate(${x - 10} ${y - fontSize})`);
    
    // Replace text with path
    svg.insertBefore(pathElem, selectedElement);
    selectedElement.remove();
    selectedElement = pathElem;
    
    alert('Text converted to path! (Note: This is a basic implementation. For perfect results, use professional tools.)');
  } else {
    alert('Text-to-path conversion requires more complex algorithms. This is a demonstration feature.');
  }
}

// Basic path tracing (simplified)
function tracePath(imageData, width, height) {
  // This is a placeholder for actual vectorization
  // Real implementation would use marching squares or similar algorithms
  return null; // Return null to trigger the alert
}

// === SVG IMPORT ===
function importSVG() {
  document.getElementById('svgFileInput').click();
}

function handleSVGUpload(event) {
  let file = event.target.files[0];
  if(!file) return;
  
  let reader = new FileReader();
  reader.onload = function(e) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(e.target.result, 'image/svg+xml');
    let importedSVG = doc.querySelector('svg');
    
    if(importedSVG) {
      saveState();
      
      // Import all children
      while(importedSVG.firstChild) {
        svg.appendChild(importedSVG.firstChild);
      }
      
      alert('SVG imported successfully!');
    }
  };
  reader.readAsText(file);
}

// === DRAWING & INTERACTION ===
svg.addEventListener("mousedown", (e) => {
  let rect = svg.getBoundingClientRect();
  startX = (e.clientX - rect.left) * (svg.viewBox.baseVal.width / rect.width);
  startY = (e.clientY - rect.top) * (svg.viewBox.baseVal.height / rect.height);

  // SELECT & MOVE
  if (tool === "select") {
    if (e.target !== svg) { 
      // Remove previous selection outline
      if(selectedElement) {
        selectedElement.classList.remove('selected-outline');
      }
      
      selectedElement = e.target;
      selectedElement.classList.add('selected-outline');
      isDrawing = true;
      
      // Update controls if text
      if(selectedElement.tagName === 'text') {
        document.getElementById('fontSelect').value = selectedElement.getAttribute('font-family') || 'Arial';
        document.getElementById('fontSize').value = selectedElement.getAttribute('font-size') || 32;
      }
      
      // Calculate offset
      let ex = parseFloat(selectedElement.getAttribute("x") || selectedElement.getAttribute("cx") || 0);
      let ey = parseFloat(selectedElement.getAttribute("y") || selectedElement.getAttribute("cy") || 0);
      
      if(selectedElement.tagName === "path") { ex = 0; ey = 0; }
      
      offset.x = startX - ex;
      offset.y = startY - ey;
    } else {
      // Clicked on empty canvas
      if(selectedElement) {
        selectedElement.classList.remove('selected-outline');
        selectedElement = null;
      }
    }
    return;
  }

  // DRAWING
  isDrawing = true;
  saveState(); // Save state before drawing new element

  if (tool === "rect") {
    currentElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    currentElement.setAttribute("x", startX);
    currentElement.setAttribute("y", startY);
    currentElement.setAttribute("width", 0);
    currentElement.setAttribute("height", 0);
    applyStyles(currentElement);
    svg.appendChild(currentElement);
  }

  if (tool === "circle") {
    currentElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    currentElement.setAttribute("cx", startX);
    currentElement.setAttribute("cy", startY);
    currentElement.setAttribute("r", 0);
    applyStyles(currentElement);
    svg.appendChild(currentElement);
  }

  if (tool === "path") {
    currentElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    currentElement.setAttribute("d", `M ${startX} ${startY}`);
    applyStyles(currentElement);
    currentElement.setAttribute("fill", "none"); 
    svg.appendChild(currentElement);
  }

  if (tool === "text") {
    let text = prompt("Enter text:");
    if (text) {
        let tElem = document.createElementNS("http://www.w3.org/2000/svg", "text");
        tElem.setAttribute("x", startX);
        tElem.setAttribute("y", startY);
        tElem.setAttribute("font-family", document.getElementById("fontSelect").value);
        tElem.setAttribute("font-size", document.getElementById("fontSize").value);
        tElem.textContent = text;
        applyStyles(tElem);
        svg.appendChild(tElem);
    }
    isDrawing = false;
  }
});

svg.addEventListener("mousemove", (e) => {
  if (!isDrawing) return;
  
  let rect = svg.getBoundingClientRect();
  let x = (e.clientX - rect.left) * (svg.viewBox.baseVal.width / rect.width);
  let y = (e.clientY - rect.top) * (svg.viewBox.baseVal.height / rect.height);

  // MOVING
  if (tool === "select" && selectedElement) {
    const tag = selectedElement.tagName;
    if (tag === "rect" || tag === "text") {
        selectedElement.setAttribute("x", x - offset.x);
        selectedElement.setAttribute("y", y - offset.y);
    } else if (tag === "circle") {
        selectedElement.setAttribute("cx", x - offset.x);
        selectedElement.setAttribute("cy", y - offset.y);
    } else if (tag === "path") {
        let dx = x - startX;
        let dy = y - startY;
        selectedElement.setAttribute("transform", `translate(${dx} ${dy})`);
    }
    return;
  }

  // DRAWING
  if (!currentElement) return;

  if (tool === "rect") {
    let w = Math.abs(x - startX);
    let h = Math.abs(y - startY);
    let newX = (x < startX) ? x : startX;
    let newY = (y < startY) ? y : startY;
    
    currentElement.setAttribute("width", w);
    currentElement.setAttribute("height", h);
    currentElement.setAttribute("x", newX);
    currentElement.setAttribute("y", newY);
  }

  if (tool === "circle") {
    let r = Math.sqrt((x - startX) ** 2 + (y - startY) ** 2);
    currentElement.setAttribute("r", r);
  }

  if (tool === "path") {
    let d = currentElement.getAttribute("d");
    currentElement.setAttribute("d", d + ` L ${x} ${y}`);
  }
});

svg.addEventListener("mouseup", () => {
  if(isDrawing && tool === "select" && selectedElement) {
    saveState(); // Save state after moving
  }
  isDrawing = false;
  currentElement = null;
});

function applyStyles(el) {
  el.setAttribute("fill", document.getElementById("fillColor").value);
  el.setAttribute("stroke", document.getElementById("strokeColor").value);
  el.setAttribute("stroke-width", document.getElementById("strokeWidth").value);
}

// === DOWNLOAD ===
function downloadSVG() {
  // Clone SVG to remove visual-only classes
  let clone = svg.cloneNode(true);
  clone.querySelectorAll('.selected-outline').forEach(el => {
    el.classList.remove('selected-outline');
  });
  
  let source = clone.outerHTML;
  if(!source.match(/^<svg[^>]+xmlns="http:\/\/www\.w3\.org\/2000\/svg"/)){
      source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
  }
  
  let blob = new Blob([source], { type: "image/svg+xml" });
  let url = URL.createObjectURL(blob);
  let a = document.createElement("a");
  a.href = url;
  a.download = "inkrealm-design.svg";
  a.click();
  URL.revokeObjectURL(url);
}

// === KEYBOARD SHORTCUTS ===
window.addEventListener('keydown', (e) => {
  if(e.key === 'Delete' || e.key === 'Backspace') {
    e.preventDefault();
    deleteSelected();
  }
  if((e.ctrlKey || e.metaKey) && e.key === 'z') {
    e.preventDefault();
    undo();
  }
  if((e.ctrlKey || e.metaKey) && e.key === 'y') {
    e.preventDefault();
    redo();
  }
});

// === TOUCH SUPPORT ===
function touchHandler(event) {
    var touches = event.changedTouches,
        first = touches[0],
        type = "";
    switch(event.type) {
        case "touchstart": type = "mousedown"; break;
        case "touchmove":  type = "mousemove"; break;
        case "touchend":   type = "mouseup";   break;
        default: return;
    }
    var simulatedEvent = new MouseEvent(type, {
        bubbles: true, cancelable: true, view: window,
        screenX: first.screenX, screenY: first.screenY,
        clientX: first.clientX, clientY: first.clientY
    });
    first.target.dispatchEvent(simulatedEvent);
    if(event.type === "touchmove") event.preventDefault();
}
svg.addEventListener("touchstart", touchHandler, true);
svg.addEventListener("touchmove", touchHandler, true);
svg.addEventListener("touchend", touchHandler, true);

// === INITIALIZE ===
saveState(); // Save initial empty state
updateHistoryUI();
</script>

</body>
</html>
