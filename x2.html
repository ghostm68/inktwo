<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TF.js AI Notepad</title>
<style>
  body {
    background: #121212;
    color: #eee;
    font-family: Arial, sans-serif;
    padding: 20px;
    max-width: 640px;
    margin: auto;
  }
  textarea, select, button {
    width: 100%;
    font-family: monospace;
    font-size: 14px;
    margin: 10px 0;
    padding: 8px;
    box-sizing: border-box;
    border-radius: 4px;
    border: 1px solid #555;
    background: #222;
    color: #eee;
    resize: vertical;
  }
  button {
    background: #cc0000;
    color: #fff;
    border: none;
    cursor: pointer;
  }
  button:disabled {
    background: #555;
    cursor: not-allowed;
  }
  #ai-output {
    white-space: pre-wrap;
    padding: 10px;
    background: #222;
    border: 1px solid #555;
    min-height: 150px;
    max-height: 300px;
    overflow-y: auto;
    margin-top: 10px;
  }
  #status {
    font-size: 13px;
    color: #aaa;
  }
</style>

<!-- TensorFlow.js -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.9.0/dist/tf.min.js"></script>
</head>
<body>

<h1>TF.js AI Notepad</h1>

<label for="model-select">Choose AI Model:</label>
<select id="model-select" aria-label="Choose AI Model">
  <option value="distilgpt2">DistilGPT2 (Text Generation)</option>
  <option value="mobilebert">MobileBERT (Fill-mask)</option>
  <option value="t5-small">T5 Small (Text-to-text)</option>
  <option value="sentiment">Sentiment Analysis (Positive/Negative)</option>
</select>

<label for="prompt-input">Enter your prompt:</label>
<textarea id="prompt-input" rows="4" placeholder="Type your prompt here..."></textarea>

<button id="generate-btn">Generate Text</button>

<div id="status"></div>

<h2>AI Output / Text</h2>
<textarea id="ai-output" rows="10" placeholder="AI generated text or your writing..."></textarea>

<button id="save-btn">Save to TXT</button>

<script type="module" data-cfasync="false">
  import { pipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.1.0';

  let models = {};
  const statusEl = document.getElementById('status');
  const generateBtn = document.getElementById('generate-btn');
  const saveBtn = document.getElementById('save-btn');
  const modelSelect = document.getElementById('model-select');
  const promptInput = document.getElementById('prompt-input');
  const aiOutput = document.getElementById('ai-output');

  // Removed HF_TOKEN. This should allow transformers.js to try fetching public models without auth.

  async function loadModels() {
    statusEl.textContent = 'Initializing Xenova Transformers...';
    try {
      generateBtn.disabled = true; // Disable button during loading

      // No commonPipelineOptions with token, letting it attempt public access
      // If unauthorized errors persist after clearing cache, then self-hosting is the next step.

      statusEl.textContent = 'Loading DistilGPT2 (Text Generation)...';
      models.distilgpt2 = await pipeline('text-generation', 'Xenova/distilgpt2');
      statusEl.textContent = 'DistilGPT2 loaded. Loading MobileBERT...';

      statusEl.textContent = 'Loading MobileBERT (Fill-mask)...';
      models.mobilebert = await pipeline('fill-mask', 'Xenova/mobilebert-base-cased');
      statusEl.textContent = 'MobileBERT loaded. Loading T5 Small...';

      statusEl.textContent = 'Loading T5 Small (Text-to-text)...';
      models['t5-small'] = await pipeline('text2text-generation', 'Xenova/t5-small');
      statusEl.textContent = 'T5 Small loaded. Loading Sentiment Analysis...';

      statusEl.textContent = 'Loading Sentiment Analysis (Positive/Negative)...';
      models.sentiment = await pipeline('sentiment-analysis', 'Xenova/distilbert-base-uncased-finetuned-sst-2-english');
      statusEl.textContent = 'Sentiment Analysis loaded.';

      statusEl.textContent = 'All models loaded. Ready.';
      generateBtn.disabled = false;
    } catch(e) {
      statusEl.textContent = 'Error loading models: ' + e.message + '. Please ensure you have an internet connection and the Xenova CDN is accessible. Check browser console for more details.';
      generateBtn.disabled = true;
      console.error('Model loading error:', e);
    }
  }

  async function generateText() {
    const modelKey = modelSelect.value;
    const prompt = promptInput.value.trim();
    if (!prompt) {
      alert('Please enter a prompt.');
      return;
    }

    generateBtn.disabled = true;
    statusEl.textContent = `Processing with ${modelKey} model...`;
    aiOutput.value = ''; // Clear previous output

    try {
      let output;
      if (modelKey === 'mobilebert') {
        const maskedPrompt = prompt.includes('[MASK]') ? prompt : prompt + ' [MASK]';
        const results = await models.mobilebert(maskedPrompt, { top_k: 5 });
        output = results.map(r => `"${r.sequence}" (score: ${r.score.toFixed(4)})`).join('\n');
      } else if (modelKey === 't5-small') {
        const results = await models['t5-small'](prompt, {
            max_length: 50,
            do_sample: true,
            temperature: 0.8,
            num_return_sequences: 1
        });
        output = results[0].generated_text;
      } else if (modelKey === 'distilgpt2') {
        const results = await models.distilgpt2(prompt, {
            max_new_tokens: 50,
            do_sample: true,
            temperature: 0.7,
            top_k: 50,
            num_return_sequences: 1
        });
        output = results[0].generated_text;
      } else if (modelKey === 'sentiment') {
        const results = await models.sentiment(prompt);
        output = `Sentiment: ${results[0].label} (Score: ${results[0].score.toFixed(4)})`;
      }
      else {
        output = `Model ${modelKey} not implemented.`;
      }
      aiOutput.value = output;
      statusEl.textContent = 'Generation complete.';
    } catch(err) {
      statusEl.textContent = 'Error during generation: ' + err.message;
      console.error('Generation error for model ' + modelKey + ':', err);
    } finally {
      generateBtn.disabled = false;
    }
  }

  function saveText() {
    const text = aiOutput.value;
    if (!text) {
      alert('Nothing to save!');
      return;
    }
    const blob = new Blob([text], {type: 'text/plain;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'notepad_output.txt';
    a.click();
    URL.revokeObjectURL(url);
  }

  generateBtn.disabled = true;
  generateBtn.addEventListener('click', generateText);
  saveBtn.addEventListener('click', saveText);

  document.addEventListener('DOMContentLoaded', loadModels);
</script>
</body>
</html>
