<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>fadeaway — hybrid notepad + dither (with Ghost Playground)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --gap: 10px;
      --panel-bg: #f8f8f8;
      --ui-bg: #fafafa;
      --accent: #2b6cb0;
    }
    html,body { height:100%; margin:0; font-family: "IBMMonoCustom", ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    /* load local IBM font fallback (raw GitHub) */
    @font-face {
      font-family: 'IBMMonoCustom';
      src: url('https://raw.githubusercontent.com/ghostm68/inktwo/main/soviet-program/ibm-extended/IBMPlexMono-Medium.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }
    /* layout */
    .app { display:flex; height:100vh; gap:var(--gap); background:#efefef; }
    .editor-pane { width:50%; display:flex; flex-direction:column; border-right:1px solid #ccc; position:relative; background:white; min-width:320px; }
    .editor-top { padding:10px; display:flex; align-items:center; justify-content:space-between; gap:8px; border-bottom:1px solid #eee; background:var(--ui-bg); }
    .editor-controls { display:flex; gap:8px; align-items:center; }
    #editorWrap { position:relative; flex:1; overflow:hidden; min-height:220px; }
    textarea#notepad { position:absolute; inset:0; width:100%; height:100%; margin:0; padding:20px; border:none; outline:none; resize:none; font-family:"IBMMonoCustom", monospace; font-size:16px; line-height:1.35; background:transparent; color:#121212; z-index:1; box-sizing:border-box; overflow:auto; }
    /* p5 canvas holder sits above the textarea */
    #drawCanvas { position:absolute; inset:0; z-index:2; pointer-events:none; }
    .hint { font-size:12px; color:#666; margin-left:8px; }

    .btn { background:#fff; border:1px solid #ccc; padding:6px 8px; cursor:pointer; border-radius:4px; }
    .btn.primary { background:var(--accent); color:#fff; border-color:var(--accent); }
    .small { padding:4px 6px; font-size:13px; }

    .dither-pane { width:50%; padding:12px; box-sizing:border-box; background:var(--panel-bg); overflow:auto; min-width:320px; }
    .control-row { margin-bottom:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    label { font-size:13px; color:#222; min-width:90px; }
    select,input[type="range"],button,input[type="file"] { font-family:inherit; font-size:13px; }
    #ditherCanvas { width:100%; border:1px solid #ccc; display:block; max-width:100%; height:auto; margin-top:8px; image-rendering: pixelated; }

    footer { padding:8px 12px; font-size:12px; color:#555; background:#fafafa; border-top:1px solid #eee; }

    /* slide-out full-page ghost menu */
    .ghost-menu {
      position: fixed;
      top: 0;
      right: -100%;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.98);
      box-shadow: -6px 0 18px rgba(0,0,0,0.2);
      transition: right 320ms cubic-bezier(.2,.9,.2,1);
      z-index:9999;
      display:flex;
      flex-direction:column;
    }
    .ghost-menu.open { right: 0; }
    .ghost-header { display:flex; align-items:center; justify-content:space-between; padding:12px 16px; border-bottom:1px solid #eee; background:#fff; }
    .ghost-controls { padding:12px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; background:#fafafa; border-bottom:1px solid #eee; }
    .ghost-canvas-wrap { flex:1; display:flex; align-items:stretch; justify-content:center; padding:12px; }
    #ghostCanvas { width:100%; max-width:1600px; height:100%; border:1px solid #ddd; background:#fff; }

    .help { position: absolute; right:16px; bottom:16px; font-size:12px; color:#444; background: rgba(255,255,255,0.9); padding:6px 10px; border-radius:6px; border:1px solid #eee; }

    @media (max-width:900px) {
      .app { flex-direction:column; }
      .editor-pane,.dither-pane { width:100%; height:50vh; }
    }

  </style>

  <!-- load IBM Plex alternatives from Google -->
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&family=IBM+Plex+Sans&family=IBM+Plex+Serif&display=swap" rel="stylesheet">
  <!-- p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <!-- html2canvas for PNG merging (fallback) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
  <div class="app">
    <!-- LEFT: Editor + drawing overlay -->
    <section class="editor-pane" aria-label="Editor and drawing area">
      <div class="editor-top">
        <div style="display:flex; align-items:center; gap:12px;">
          <h5 style="margin:0; font-size:18px;">fadeaway</h5>
          <span class="hint">— hybrid notepad (press <strong>D</strong> to toggle drawing)</span>
        </div>

        <div class="editor-controls">
          <label for="fontSelect" style="margin:0;">ibm font select</label>
          <select id="fontSelect" title="Choose font">
            <option value='"IBMMonoCustom", "IBM Plex Mono", monospace'>IBM Plex Mono (IBM)</option>
            <option value='"IBM Plex Sans", sans-serif'>IBM Plex Sans</option>
            <option value='"IBM Plex Serif", serif'>IBM Plex Serif</option>
            <option value='monospace'>System Mono</option>
          </select>

          <div style="display:flex; gap:8px; align-items:center;">
            <button id="exportTxtBtn" class="btn small">xport .txt</button>
            <button id="exportPngBtn" class="btn small">xport .png</button>
            <button id="exportSvgBtn" class="btn small">xport .svg</button>
            <button id="clearDrawingBtn" class="btn small">drawclear</button>
            <button id="openGhostMenu" class="btn small"><font color="yellow">Ghost</font color="yellow"></button>
          </div>
        </div>
      </div>

      <div id="editorWrap">
        <textarea id="notepad" spellcheck="false">Welcome to fadeaway
Type here — toggle drawing with the "D" key and draw over the page. Use the Ghost for flowfield experiments.</textarea>

        <!-- main drawing canvas (global p5 sketch) -->
        <div id="drawCanvas"></div>
      </div>

      <footer>
        Drawing strokes saved as SVG paths. Text uses IBM font from repo. Ghost Playground is separate.
      </footer>
    </section>

    <!-- RIGHT: Dithering playground (unchanged core) -->
    <aside class="dither-pane" aria-label="Dithering playground">
      <h3 style="margin-top:0">Dithering Playground</h3>

      <div class="control-row">
        <label for="uploadImage">Upload image:</label>
        <input id="uploadImage" type="file" accept="image/*" />
      </div>

      <div class="control-row">
        <label for="algoSelect">Algorithm:</label>
        <select id="algoSelect">
          <option value="floyd">Floyd–Steinberg</option>
          <option value="atkinson">Atkinson</option>
          <option value="bayer">Bayer Ordered (4x4)</option>
          <option value="threshold">Threshold</option>
          <option value="random">Random</option>
        </select>

        <label for="paletteSelect">Palette:</label>
        <select id="paletteSelect">
          <option value="bw">Black & White</option>
          <option value="grayscale">Grayscale</option>
          <option value="4level">4-level</option>
        </select>
      </div>

      <div class="control-row">
        <label for="scaleRange">Scale (pixel size):</label>
        <input id="scaleRange" type="range" min="1" max="12" value="2" />
        <span id="scaleVal">2</span>
      </div>

      <div class="control-row">
        <label for="thresholdRange">Threshold:</label>
        <input id="thresholdRange" type="range" min="0" max="255" value="128" />
        <span id="thresholdVal">128</span>
      </div>

      <div class="control-row">
        <button id="applyDitherBtn" class="btn small primary">Apply Dither</button>
        <button id="downloadDitherBtn" class="btn small">Download Dither PNG</button>
        <button id="resetDitherBtn" class="btn small">Reset</button>
      </div>

      <canvas id="ditherCanvas"></canvas>

      <div style="margin-top:12px; font-size:12px; color:#444;">
        Algorithms: Floyd–Steinberg, Atkinson, Ordered Bayer, Threshold, Random. Palettes: BW / grayscale / 4-level.
      </div>
    </aside>
  </div>

  <!-- FULL-PAGE GHOST PLAYGROUND (slide-out) -->
  <div id="ghostMenu" class="ghost-menu" aria-hidden="true">
    <div class="ghost-header">
      <div>
        <strong>Ghost Playground</strong>
        <span style="margin-left:8px; color:#666; font-size:13px;">flowfield & particle trails</span>
      </div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="ghostEnableBtn" class="btn small">Enable Ghost</button>
        <button id="ghostResetBtn" class="btn small">Reset</button>
        <button id="closeGhostMenu" class="btn small">Close</button>
      </div>
    </div>

    <div class="ghost-controls">
      <label>Particles</label>
      <input id="ghostParticles" type="range" min="10" max="800" value="120" />
      <span id="ghostParticlesVal">120</span>

      <label>Speed</label>
      <input id="ghostSpeed" type="range" min="0.1" max="3" step="0.1" value="0.8" />
      <span id="ghostSpeedVal">0.8</span>

      <label>Trail fade</label>
      <input id="ghostFade" type="range" min="2" max="60" step="1" value="18" />
      <span id="ghostFadeVal">18</span>
    </div>

    <div class="ghost-canvas-wrap">
      <div id="ghostCanvas" style="width:100%; height:100%;"></div>
    </div>
  </div>

  <div class="help">Hotkeys: D = Draw, G = Toggle Ghost in Playground</div>

  <!-- SCRIPT: full app logic (commented) -->
  <script>
  /* ====================================================
     Fadeaway — combined script
     - Global p5 sketch for main drawing overlay (keeps original behaviour)
     - p5 instance for Ghost Playground in slide menu (isolated)
     - Font selector, exports, dithering, and controls wired
     ==================================================== */

  // ---------- UTIL ----------
  function $id(id){ return document.getElementById(id); }
  function $(sel){ return document.querySelector(sel); }

  // Basic UI refs
  const notepad = $id('notepad');
  const fontSelect = $id('fontSelect');
  const exportTxtBtn = $id('exportTxtBtn');
  const exportPngBtn = $id('exportPngBtn');
  const exportSvgBtn = $id('exportSvgBtn');
  const clearDrawingBtn = $id('clearDrawingBtn');

  const openGhostMenuBtn = $id('openGhostMenu');
  const ghostMenu = $id('ghostMenu');
  const closeGhostMenuBtn = $id('closeGhostMenu');
  const ghostEnableBtn = $id('ghostEnableBtn');
  const ghostResetBtn = $id('ghostResetBtn');
  const ghostParticlesSlider = $id('ghostParticles');
  const ghostParticlesVal = $id('ghostParticlesVal');
  const ghostSpeedSlider = $id('ghostSpeed');
  const ghostSpeedVal = $id('ghostSpeedVal');
  const ghostFadeSlider = $id('ghostFade');
  const ghostFadeVal = $id('ghostFadeVal');

  // Dither refs
  const uploadInput = $id('uploadImage');
  const ditherCanvas = $id('ditherCanvas');
  const dCtx = ditherCanvas.getContext('2d');
  const algoSelect = $id('algoSelect');
  const paletteSelect = $id('paletteSelect');
  const scaleRange = $id('scaleRange');
  const scaleVal = $id('scaleVal');
  const thresholdRange = $id('thresholdRange');
  const thresholdVal = $id('thresholdVal');
  const applyDitherBtn = $id('applyDitherBtn');
  const downloadDitherBtn = $id('downloadDitherBtn');
  const resetDitherBtn = $id('resetDitherBtn');

  scaleVal.textContent = scaleRange.value;
  thresholdVal.textContent = thresholdRange.value;
  scaleRange.addEventListener('input', ()=> scaleVal.textContent = scaleRange.value );
  thresholdRange.addEventListener('input', ()=> thresholdVal.textContent = thresholdRange.value );

  // ---------- STATE for main editor/drawing ----------
  let drawingEnabled = false;       // toggled via D key
  let paths = [];                   // recorded strokes (arrays of points)
  let currentStroke = [];           // building stroke
  let sketchW = 800, sketchH = 600; // canvas size used for export
  // main p5 canvas is created in global mode (so p5 calls setup/draw automatically)

  // font selector wiring (applies to textarea)
  fontSelect.addEventListener('change', (e)=> { notepad.style.fontFamily = e.target.value; });
  // apply initial font
  notepad.style.fontFamily = fontSelect.value;

  /* ============================
     MAIN DRAWING SKETCH (global p5)
     - lightweight drawing overlay for the notepad
     - no flowfield here (that lives in the Ghost Playground)
     ============================ */
  function setup(){
    // size to editorWrap
    const wrap = document.getElementById('editorWrap');
    const rect = wrap.getBoundingClientRect();
    sketchW = Math.max(240, Math.floor(rect.width));
    sketchH = Math.max(160, Math.floor(rect.height));
    const cnv = createCanvas(sketchW, sketchH);
    cnv.parent('drawCanvas');
    clear(); // transparent
    stroke(0);
    strokeWeight(2);
    noFill();
    // drawing overlay should not block typing by default
    document.getElementById('drawCanvas').style.pointerEvents = 'none';
  }

  function draw(){
    // main draw loop doesn't animate anything — just leaves current pixels (so strokes persist)
    // nothing to update here unless user is drawing (handled in mouseDragged)
  }

  function mouseDragged(){
    if (!drawingEnabled) return;
    // only draw when mouse is over the canvas area
    if (mouseX < 0 || mouseY < 0 || mouseX > width || mouseY > height) return;
    line(pmouseX, pmouseY, mouseX, mouseY);
    currentStroke.push({ x: mouseX, y: mouseY });
  }

  function mouseReleased(){
    if (currentStroke.length > 0) {
      paths.push(currentStroke.slice());
      currentStroke = [];
    }
  }

  function keyPressed(evt){
    // toggle drawing with D
    if (key === 'd' || key === 'D') {
      drawingEnabled = !drawingEnabled;
      document.getElementById('drawCanvas').style.pointerEvents = drawingEnabled ? 'auto' : 'none';
      document.getElementById('drawCanvas').style.cursor = drawingEnabled ? 'crosshair' : 'default';
    }
    // if user presses G while ghost playground open, forward to ghost instance via event (below)
  }

  // redraw recorded strokes (used after resize)
  function redrawDrawingFromPaths(){
    clear();
    stroke(0);
    strokeWeight(2);
    noFill();
    for (const strokePath of paths){
      if (!strokePath || strokePath.length < 2) continue;
      beginShape();
      for (const p of strokePath) vertex(p.x, p.y);
      endShape();
    }
  }

  // clear drawing button clears recorded strokes and canvas, but not notepad text
  clearDrawingBtn.addEventListener('click', ()=> {
    paths = [];
    currentStroke = [];
    clear();
    redrawDrawingFromPaths();
    // Also stop ghost playground if open (non-destructive)
    if (ghostInstance && ghostInstance.isRunning) {
      ghostInstance.disable(); // defined in ghost instance interface below
    }
  });

  // handle window resize for main canvas
  window.addEventListener('resize', ()=> {
    setTimeout(()=> {
      const wrap = document.getElementById('editorWrap');
      const rect = wrap.getBoundingClientRect();
      sketchW = Math.max(240, Math.floor(rect.width));
      sketchH = Math.max(160, Math.floor(rect.height));
      resizeCanvas(sketchW, sketchH);
      // redraw existing strokes scaled approx. (we keep same coords so just replay)
      redrawDrawingFromPaths();
    }, 80);
  });

  /* ============================
     EXPORTS (TXT, PNG, SVG)
     - PNG merges textarea (rendered text) + p5 canvas drawing
     - SVG builds vector paths for strokes + text as <text> with IBM font
     ============================ */

  // TXT export
  exportTxtBtn.addEventListener('click', ()=> {
    const blob = new Blob([notepad.value], { type:'text/plain;charset=utf-8' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'fadeaway.txt';
    a.click();
    URL.revokeObjectURL(a.href);
  });

  // PNG export: render text onto temp canvas then draw p5 canvas on top
  exportPngBtn.addEventListener('click', async ()=> {
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = sketchW;
    exportCanvas.height = sketchH;
    const ctx = exportCanvas.getContext('2d');

    // white background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,exportCanvas.width, exportCanvas.height);

    // draw text (basic wrapping)
    const textLines = notepad.value.split('\n');
    const fontSize = 16;
    ctx.fillStyle = '#000';
    // use the chosen font
    const fontFamily = (notepad.style.fontFamily || 'IBMMonoCustom, monospace').replace(/"/g,'');
    ctx.font = `${fontSize}px ${fontFamily}`;
    ctx.textBaseline = 'top';
    const lineHeight = Math.round(fontSize * 1.35);
    const padding = 20;
    let y = padding;
    for (let i=0;i<textLines.length;i++){
      const txt = textLines[i];
      if (ctx.measureText(txt).width <= exportCanvas.width - padding*2) {
        ctx.fillText(txt, padding, y);
        y += lineHeight;
      } else {
        let remaining = txt;
        while (remaining.length > 0 && y < exportCanvas.height - padding) {
          let fit = remaining;
          while (ctx.measureText(fit).width > exportCanvas.width - padding*2 && fit.length>1) fit = fit.slice(0,-1);
          ctx.fillText(fit, padding, y);
          remaining = remaining.slice(fit.length);
          y += lineHeight;
        }
      }
      if (y > exportCanvas.height - padding) break;
    }

    // draw p5 canvas onto export
    const p5canvas = document.querySelector('#drawCanvas canvas');
    if (p5canvas) ctx.drawImage(p5canvas, 0, 0, exportCanvas.width, exportCanvas.height);

    const a = document.createElement('a');
    a.href = exportCanvas.toDataURL('image/png');
    a.download = 'fadeaway.png';
    a.click();
  });

  // SVG export: text as <text>, strokes as <path>
  exportSvgBtn.addEventListener('click', ()=> {
    const width = sketchW, height = sketchH;
    const lines = notepad.value.split('\n');
    const fontSize = 16;
    const lineHeight = Math.round(fontSize * 1.35);
    const padding = 20;

    function esc(t){ return t.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&apos;'); }

    let svg = `<?xml version="1.0" encoding="utf-8"?>\n`;
    svg += `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">\n`;
    svg += `<style>@font-face{font-family:IBMMonoCustom;src:url('https://raw.githubusercontent.com/ghostm68/inktwo/main/soviet-program/ibm-extended/IBMPlexMono-Medium.ttf');} text{font-family:IBMMonoCustom, monospace; font-size:${fontSize}px;}</style>\n`;
    svg += `<rect width="100%" height="100%" fill="white"/>\n`;
    svg += `<g fill="black" font-family="IBMMonoCustom" font-size="${fontSize}">\n`;
    for (let i=0;i<lines.length;i++){
      const y = padding + i*lineHeight;
      svg += `<text x="${padding}" y="${y}">${esc(lines[i])}</text>\n`;
    }
    svg += `</g>\n`;

    svg += `<g fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">\n`;
    for (const s of paths){
      if (!s || s.length === 0) continue;
      const d = s.map((p,i)=> (i===0 ? `M ${p.x} ${p.y}` : `L ${p.x} ${p.y}`)).join(' ');
      svg += `<path d="${d}"/>\n`;
    }
    svg += `</g>\n</svg>`;

    const blob = new Blob([svg], { type:'image/svg+xml;charset=utf-8' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'fadeaway.svg';
    a.click();
    URL.revokeObjectURL(a.href);
  });

  /* ============================
     DITHERING PANEL Implementation
     (same approach as before; modular algorithms)
     ============================ */
  let sourceImage = null;
  uploadInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const img = new Image();
    img.onload = () => {
      sourceImage = img;
      const maxW = Math.min(img.width, 1200);
      const ratio = img.width > maxW ? maxW / img.width : 1;
      ditherCanvas.width = Math.round(img.width * ratio);
      ditherCanvas.height = Math.round(img.height * ratio);
      dCtx.imageSmoothingEnabled = false;
      dCtx.clearRect(0,0,ditherCanvas.width,ditherCanvas.height);
      dCtx.drawImage(img, 0, 0, ditherCanvas.width, ditherCanvas.height);
    };
    img.src = URL.createObjectURL(file);
  });

  applyDitherBtn.addEventListener('click', () => {
    if (!sourceImage) { alert('Please upload an image first.'); return; }
    dCtx.clearRect(0,0,ditherCanvas.width,ditherCanvas.height);
    dCtx.drawImage(sourceImage, 0, 0, ditherCanvas.width, ditherCanvas.height);
    applyDitherToCanvas();
  });

  resetDitherBtn.addEventListener('click', () => {
    if (sourceImage) {
      dCtx.clearRect(0,0,ditherCanvas.width,ditherCanvas.height);
      dCtx.drawImage(sourceImage, 0, 0, ditherCanvas.width, ditherCanvas.height);
    } else {
      dCtx.clearRect(0,0,ditherCanvas.width,ditherCanvas.height);
    }
  });

  downloadDitherBtn.addEventListener('click', () => {
    const a = document.createElement('a');
    a.href = ditherCanvas.toDataURL('image/png');
    a.download = 'fadeaway-dither.png';
    a.click();
  });

  function getImageDataCopy(){
    try { return dCtx.getImageData(0,0,ditherCanvas.width,ditherCanvas.height); }
    catch (e) { alert('Unable to read pixels from this image (CORS). Use a local image or same-origin resource.'); throw e; }
  }

  function applyDitherToCanvas(){
    const algo = algoSelect.value;
    const palette = paletteSelect.value;
    const displayScale = parseInt(scaleRange.value,10) || 1;
    const threshold = parseInt(thresholdRange.value,10) || 128;
    const src = getImageDataCopy();
    const w = src.width, h = src.height;
    const lum = new Float32Array(w*h);
    for (let i=0;i<w*h;i++){
      const di = i*4;
      const r = src.data[di], g = src.data[di+1], b = src.data[di+2];
      lum[i] = 0.299*r + 0.587*g + 0.114*b;
    }
    const out = new Uint8ClampedArray(w*h*4);
    // algorithms
    if (algo === 'threshold') {
      for (let i=0;i<w*h;i++){ const v = lum[i] < threshold ? 0 : 255; writeOutTo(out, i, v, palette); }
    } else if (algo === 'random') {
      for (let i=0;i<w*h;i++){ const v = (lum[i] < Math.random()*255) ? 0 : 255; writeOutTo(out, i, v, palette); }
    } else if (algo === 'bayer') {
      const bayer = [[0,8,2,10],[12,4,14,6],[3,11,1,9],[15,7,13,5]];
      for (let y=0;y<h;y++) for (let x=0;x<w;x++){ const i = y*w+x; const m = bayer[y%4][x%4]/16; const val = lum[i]/255; const v = (val < m)?0:255; writeOutTo(out,i,v,palette); }
    } else if (algo === 'floyd') {
      const buf = new Float32Array(lum);
      for (let y=0;y<h;y++) for (let x=0;x<w;x++){ const idx=y*w+x; const oldv=buf[idx]; const newv=oldv<threshold?0:255; const err=oldv-newv; writeOutTo(out, idx, newv, palette); if (x+1<w) buf[idx+1]+=err*7/16; if (x-1>=0&&y+1<h) buf[idx+w-1]+=err*3/16; if (y+1<h) buf[idx+w]+=err*5/16; if (x+1<w && y+1<h) buf[idx+w+1]+=err*1/16; }
    } else if (algo === 'atkinson') {
      const buf = new Float32Array(lum);
      for (let y=0;y<h;y++) for (let x=0;x<w;x++){ const idx=y*w+x; const oldv=buf[idx]; const newv=oldv<threshold?0:255; const err=(oldv-newv)/8; writeOutTo(out, idx, newv, palette); distribute(buf,x+1,y,w,h,err); distribute(buf,x+2,y,w,h,err); distribute(buf,x-1,y+1,w,h,err); distribute(buf,x,y+1,w,h,err); distribute(buf,x+1,y+1,w,h,err); distribute(buf,x,y+2,w,h,err); }
    }
    const imgOut = new ImageData(out, w, h);
    const tmp = document.createElement('canvas'); tmp.width=w; tmp.height=h; const tCtx = tmp.getContext('2d'); tCtx.putImageData(imgOut,0,0);
    dCtx.imageSmoothingEnabled = false;
    ditherCanvas.width = w*displayScale; ditherCanvas.height = h*displayScale;
    dCtx.clearRect(0,0,ditherCanvas.width,ditherCanvas.height);
    dCtx.drawImage(tmp, 0, 0, ditherCanvas.width, ditherCanvas.height);
  }

  function writeOutTo(outArr, i, v, palette){
    let r,g,b;
    if (palette === 'bw') { r=g=b = v < 128 ? 0 : 255; }
    else if (palette === 'grayscale') { r=g=b = Math.round(v); }
    else if (palette === '4level') { let level; if (v<64) level=0; else if (v<128) level=85; else if (v<192) level=170; else level=255; r=g=b=level; }
    else { r=g=b=v; }
    const base = i*4; outArr[base]=r; outArr[base+1]=g; outArr[base+2]=b; outArr[base+3]=255;
  }

  function distribute(buf, x, y, w, h, err){ if (x<0||x>=w||y<0||y>=h) return; const pos=y*w+x; buf[pos]+=err; }

  /* ============================
     GHOST PLAYGROUND: p5 instance
     - isolated from main drawing
     - controls: enable, particle count, speed, fade, reset
     - interface exposed via ghostInstance object
     ============================ */
  let ghostInstance = null;
  (function createGhostInstance(){
    // define instance mode sketch
    const sketch = (p) => {
      // state inside instance
      let particles = [];
      let field = [];
      let cols = 0, rows = 0;
      let scl = 20;
      let noiseZ = 0;
      p.isRunning = false; // track whether ghost enabled
      p.particleCount = parseInt(ghostParticlesSlider.value,10);
      p.speedMult = parseFloat(ghostSpeedSlider.value);
      p.fadeAlpha = parseInt(ghostFadeSlider.value,10);

      p.setup = function(){
        const container = document.getElementById('ghostCanvas');
        // create canvas sized to container
        const rect = container.getBoundingClientRect();
        const w = Math.max(320, Math.floor(rect.width));
        const h = Math.max(240, Math.floor(rect.height));
        p.cnv = p.createCanvas(w, h);
        p.cnv.parent('ghostCanvas');
        p.background(255);
        p.pixelDensity(1);
        // init
        cols = Math.ceil(p.width / scl);
        rows = Math.ceil(p.height / scl);
        field = new Array(cols*rows).fill(0);
        p.initParticles();
      };

      p.initParticles = function(){
        particles = [];
        for (let i=0;i<p.particleCount;i++){
          particles.push({
            x: Math.random()*p.width,
            y: Math.random()*p.height,
            vx:0, vy:0
          });
        }
      };

      p.updateField = function(){
        let i=0;
        let inc = 0.12;
        for (let y=0;y<rows;y++){
          for (let x=0;x<cols;x++){
            const nx = x*inc;
            const ny = y*inc;
            const angle = p.noise(nx, ny, noiseZ) * p.TWO_PI * 2;
            field[i++] = angle;
          }
        }
        noiseZ += 0.006 * p.speedMult;
      };

      p.runParticles = function(){
        p.stroke(30,30,30,100);
        p.strokeWeight(1.2);
        for (const pt of particles){
          const col = Math.floor(pt.x / scl);
          const row = Math.floor(pt.y / scl);
          const idx = Math.max(0, Math.min(field.length-1, row*cols + col));
          const angle = field[idx] || 0;
          const ax = Math.cos(angle) * 0.3 * p.speedMult;
          const ay = Math.sin(angle) * 0.3 * p.speedMult;
          pt.vx = (pt.vx + ax) * 0.96;
          pt.vy = (pt.vy + ay) * 0.96;
          const px = pt.x, py = pt.y;
          pt.x += pt.vx; pt.y += pt.vy;
          if (pt.x < 0) pt.x = p.width;
          if (pt.x > p.width) pt.x = 0;
          if (pt.y < 0) pt.y = p.height;
          if (pt.y > p.height) pt.y = 0;
          p.line(px, py, pt.x, pt.y);
        }
      };

      p.draw = function(){
        if (!p.isRunning) return;
        // fade rectangle to create trail effect
        p.noStroke();
        p.fill(255, p.fadeAlpha); // trail fade value controls how quickly trailing disappears
        p.rect(0,0,p.width,p.height);
        // update field & run particles
        p.updateField();
        p.runParticles();
      };

      // external controls
      p.enable = function(){
        p.isRunning = true;
        p.loop();
      };
      p.disable = function(){
        p.isRunning = false;
        p.noLoop();
      };
      p.reset = function(){
        p.clear();
        p.background(255);
        p.initParticles();
        p.disable();
      };
      p.setParticleCount = function(n){
        p.particleCount = n;
        p.initParticles();
      };
      p.setSpeed = function(s){
        p.speedMult = s;
      };
      p.setFade = function(f){
        p.fadeAlpha = f;
      };

      p.windowResized = function(){
        // resize to container
        const container = document.getElementById('ghostCanvas');
        const rect = container.getBoundingClientRect();
        const w = Math.max(320, Math.floor(rect.width));
        const h = Math.max(240, Math.floor(rect.height));
        p.resizeCanvas(w,h);
        cols = Math.ceil(p.width / scl);
        rows = Math.ceil(p.height / scl);
        p.initParticles();
      };
    }; // end sketch

    // create instance but keep it disabled initially
    ghostInstance = new p5(sketch);
    // start disabled
    ghostInstance.disable();
    // set some props accessible externally
    ghostInstance.isRunning = false;
    // wire UI sliders -> reflect default values
    ghostParticlesVal.textContent = ghostParticlesSlider.value;
    ghostSpeedVal.textContent = ghostSpeedSlider.value;
    ghostFadeVal.textContent = ghostFadeSlider.value;
  })();

  // Ghost control UI wiring
  openGhostMenuBtn.addEventListener('click', ()=> {
    ghostMenu.classList.add('open'); ghostMenu.setAttribute('aria-hidden','false');
  });
  closeGhostMenuBtn.addEventListener('click', ()=> {
    ghostMenu.classList.remove('open'); ghostMenu.setAttribute('aria-hidden','true');
  });

  ghostEnableBtn.addEventListener('click', ()=> {
    if (!ghostInstance) return;
    if (!ghostInstance.isRunning) {
      ghostInstance.setParticleCount(parseInt(ghostParticlesSlider.value,10));
      ghostInstance.setSpeed(parseFloat(ghostSpeedSlider.value));
      ghostInstance.setFade(parseInt(ghostFadeSlider.value,10));
      ghostInstance.enable();
      ghostInstance.isRunning = true;
      ghostEnableBtn.textContent = 'Disable Ghost';
    } else {
      ghostInstance.disable();
      ghostInstance.isRunning = false;
      ghostEnableBtn.textContent = 'Enable Ghost';
    }
  });

  ghostResetBtn.addEventListener('click', ()=> {
    if (!ghostInstance) return;
    ghostInstance.reset();
    // reset UI
    ghostEnableBtn.textContent = 'Enable Ghost';
    ghostParticlesSlider.value = 120; ghostParticlesVal.textContent = 120;
    ghostSpeedSlider.value = 0.8; ghostSpeedVal.textContent = 0.8;
    ghostFadeSlider.value = 18; ghostFadeVal.textContent = 18;
  });

  ghostParticlesSlider.addEventListener('input', (e)=> {
    const n = parseInt(e.target.value,10);
    ghostParticlesVal.textContent = n;
    if (ghostInstance) ghostInstance.setParticleCount(n);
  });
  ghostSpeedSlider.addEventListener('input', (e)=> {
    const s = parseFloat(e.target.value);
    ghostSpeedVal.textContent = s.toFixed(1);
    if (ghostInstance) ghostInstance.setSpeed(s);
  });
  ghostFadeSlider.addEventListener('input', (e)=> {
    const f = parseInt(e.target.value,10);
    ghostFadeVal.textContent = f;
    if (ghostInstance) ghostInstance.setFade(f);
  });

  // forward global 'g' key to ghostInstance toggle when menu open
  window.addEventListener('keydown', (ev)=> {
    if ((ev.key === 'g' || ev.key === 'G') && ghostMenu.classList.contains('open')) {
      ghostEnableBtn.click();
    }
  });

  /* ============================
     Initialization / DOM readiness
     ============================ */
  (function ready(){
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', ()=> {
        // make sure p5 setup runs after DOM ready; p5 global already calls setup when loaded
        // apply font selection
        notepad.style.fontFamily = fontSelect.value;
      });
    } else {
      notepad.style.fontFamily = fontSelect.value;
    }
  })();

  console.log('Fadeaway (with Ghost Playground) loaded — ready.');

  </script>
</body>
</html>
