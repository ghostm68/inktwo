<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>fadeaway — hybrid notepad + dither</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --gap: 10px;
      --panel-bg: #f8f8f8;
      --ui-bg: #fafafa;
      --accent: #2b6cb0;
    }
    html,body { height:100%; margin:0; font-family: "IBMMonoCustom", ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    @font-face {
      font-family: 'IBMMonoCustom';
      src: url('https://raw.githubusercontent.com/ghostm68/inktwo/main/soviet-program/ibm-extended/IBMPlexMono-Medium.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }
    /* Also import IBM Plex via Google Fonts for Sans/Serif options */
    /* layout */
    .app {
      display:flex;
      height:100vh;
      gap: var(--gap);
      background: #efefef;
    }

    /* Left editor pane (50%) */
    .editor-pane {
      width:50%;
      display:flex;
      flex-direction:column;
      border-right:1px solid #ccc;
      position:relative;
      background: white;
      min-width:320px;
    }
    .editor-top {
      padding:10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      border-bottom:1px solid #eee;
      background: var(--ui-bg);
    }
    .editor-top .controls > button { margin-right:6px; }

    #editorWrap {
      position:relative;
      flex:1;
      overflow:hidden;
      min-height:220px;
    }
    textarea#notepad {
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      margin:0;
      padding:20px;
      border: none;
      outline:none;
      resize:none;
      font-family: "IBMMonoCustom", monospace;
      font-size:16px;
      line-height:1.35;
      background: transparent;
      color: #121212;
      z-index:1;
      box-sizing:border-box;
      overflow:auto;
    }
    /* p5 canvas holder sits above the textarea */
    #drawCanvas {
      position:absolute;
      inset:0;
      z-index:2;
      pointer-events:none; /* toggled to auto when drawing */
    }
    .hint {
      font-size:12px;
      color:#666;
      margin-left:8px;
    }

    .editor-controls {
      display:flex;
      gap:8px;
      align-items:center;
    }

    /* Right dither pane (50%) */
    .dither-pane {
      width:50%;
      padding:12px;
      box-sizing:border-box;
      background: var(--panel-bg);
      overflow:auto;
      min-width:320px;
    }
    .control-row { margin-bottom:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    label { font-size:13px; color:#222; min-width:90px; }
    select,input[type="range"],button,input[type="file"] { font-family:inherit; font-size:13px; }
    #ditherCanvas { width:100%; border:1px solid #ccc; display:block; max-width:100%; height:auto; margin-top:8px; image-rendering: pixelated; }

    footer { padding:8px 12px; font-size:12px; color:#555; background:#fafafa; border-top:1px solid #eee; }

    /* small responsive tweaks */
    @media (max-width: 900px) {
      .app { flex-direction: column; }
      .editor-pane, .dither-pane { width:100%; height:50vh; min-width:unset; }
      #drawCanvas { top:0; }
      textarea#notepad { padding:12px; font-size:15px; }
    }

    /* toolbar look */
    .btn { background:#fff; border:1px solid #ccc; padding:6px 8px; cursor:pointer; border-radius:4px; }
    .btn.primary { background:var(--accent); color:#fff; border-color:var(--accent); }
    .small { padding:4px 6px; font-size:13px; }
  </style>

  <!-- Google-hosted IBM Plex for alternatives -->
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&family=IBM+Plex+Sans&family=IBM+Plex+Serif&display=swap" rel="stylesheet">
  <!-- p5.js for drawing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <!-- html2canvas for full-pane PNG capture (safe fallback) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
  <div class="app">
    <section class="editor-pane" aria-label="Editor and drawing area">
      <div class="editor-top">
        <div style="display:flex; align-items:center; gap:12px;">
          <h2 style="margin:0; font-size:18px;">fadeaway</h2>
          <span class="hint">— hybrid notepad (press <strong>D</strong> to toggle drawing)</span>
        </div>

        <div class="editor-controls">
          <label for="fontSelect" style="margin:0;">Font</label>
          <select id="fontSelect" title="Choose font">
            <option value='"IBMMonoCustom", "IBM Plex Mono", monospace'>IBM Plex Mono (IBM)</option>
            <option value='"IBM Plex Sans", sans-serif'>IBM Plex Sans</option>
            <option value='"IBM Plex Serif", serif'>IBM Plex Serif</option>
            <option value='monospace'>System Mono</option>
          </select>

          <button id="ghostToggle" class="btn small">Ghost: Off</button>

          <div class="controls">
            <button id="exportTxtBtn" class="btn small">Export .txt</button>
            <button id="exportPngBtn" class="btn small">Export .png</button>
            <button id="exportSvgBtn" class="btn small">Export .svg</button>
            <button id="clearDrawingBtn" class="btn small">Clear Drawing</button>
          </div>
        </div>
      </div>

      <div id="editorWrap">
        <textarea id="notepad" spellcheck="false">Welcome to fadeaway
Type here — toggle drawing with the "D" key and draw over the page. Use the Ghost toggle (or press G) to enable flowfield trails.</textarea>
        <div id="drawCanvas" aria-hidden="false"></div>
      </div>

      <footer>
        Drawing strokes are saved as vector paths (SVG export). Text uses IBM font from repo.
      </footer>
    </section>

    <aside class="dither-pane" aria-label="Dithering playground">
      <h3 style="margin-top:0">Dithering Playground</h3>

      <div class="control-row">
        <label for="uploadImage">Upload image:</label>
        <input id="uploadImage" type="file" accept="image/*" />
      </div>

      <div class="control-row">
        <label for="algoSelect">Algorithm:</label>
        <select id="algoSelect">
          <option value="floyd">Floyd–Steinberg</option>
          <option value="atkinson">Atkinson</option>
          <option value="bayer">Bayer Ordered (4x4)</option>
          <option value="threshold">Threshold</option>
          <option value="random">Random</option>
        </select>

        <label for="paletteSelect">Palette:</label>
        <select id="paletteSelect">
          <option value="bw">Black & White</option>
          <option value="grayscale">Grayscale</option>
          <option value="4level">4-level</option>
        </select>
      </div>

      <div class="control-row">
        <label for="scaleRange">Scale (pixel size):</label>
        <input id="scaleRange" type="range" min="1" max="12" value="2" />
        <span id="scaleVal">2</span>
      </div>

      <div class="control-row">
        <label for="thresholdRange">Threshold:</label>
        <input id="thresholdRange" type="range" min="0" max="255" value="128" />
        <span id="thresholdVal">128</span>
      </div>

      <div class="control-row">
        <button id="applyDitherBtn" class="btn small primary">Apply Dither</button>
        <button id="downloadDitherBtn" class="btn small">Download Dither PNG</button>
        <button id="resetDitherBtn" class="btn small">Reset</button>
      </div>

      <canvas id="ditherCanvas"></canvas>

      <div style="margin-top:12px; font-size:12px; color:#444;">
        Algorithms: Floyd–Steinberg, Atkinson, Ordered Bayer, Threshold, Random. Palettes: BW / grayscale / 4-level.
      </div>
    </aside>
  </div>

  <script>
  /* ====================================================
     Fadeaway — production-ready one-file: p5 drawing + dither
     - Flowfield ghost mode animation
     - Drawing overlay with strokes recorded
     - Dithering playground (algorithms implemented)
     - Export: TXT, PNG, SVG
     ==================================================== */

  // ---------- UTILITY ----------
  function $(sel){ return document.querySelector(sel); }
  function $id(id){ return document.getElementById(id); }

  // ---------- STATE ----------
  const notepad = $id('notepad');
  const fontSelect = $id('fontSelect');
  const ghostToggle = $id('ghostToggle');
  const exportTxtBtn = $id('exportTxtBtn');
  const exportPngBtn = $id('exportPngBtn');
  const exportSvgBtn = $id('exportSvgBtn');
  const clearDrawingBtn = $id('clearDrawingBtn');

  let drawingEnabled = false;
  let ghostMode = false;
  let paths = [];            // array of stroke arrays, each stroke is [{x,y},...]
  let currentStroke = [];
  let sketchW = 800, sketchH = 600;

  // Setup font selector
  fontSelect.addEventListener('change', (e) => {
    notepad.style.fontFamily = e.target.value;
  });

  // ---------- P5 DRAWING + FLOWFIELD ----------
  // flowfield particles & field
  let field = [];
  let fieldCols = 0, fieldRows = 0;
  let particleSystem = [];
  const PARTICLE_COUNT = 120; // modest default

  function setup() {
    // create canvas sized to editorWrap
    const wrap = document.getElementById('editorWrap');
    resizeSketchToWrap();

    // initialize flowfield
    initFlowField();
    initParticles();
    // make sure drawing overlay doesn't intercept typing unless drawingEnabled true
    document.getElementById('drawCanvas').style.pointerEvents = 'none';
  }

  function resizeSketchToWrap(){
    const wrap = document.getElementById('editorWrap');
    const rect = wrap.getBoundingClientRect();
    sketchW = Math.max(240, Math.floor(rect.width));
    sketchH = Math.max(160, Math.floor(rect.height));
    const existing = document.querySelector('#drawCanvas canvas');
    if (existing) {
      resizeCanvas(sketchW, sketchH);
    } else {
      const cnv = createCanvas(sketchW, sketchH);
      cnv.parent('drawCanvas');
    }
  }

  function initFlowField(){
    const scale = 20; // cell size
    fieldCols = Math.ceil(sketchW / scale);
    fieldRows = Math.ceil(sketchH / scale);
    field = new Array(fieldCols * fieldRows).fill(0);
  }

  function initParticles(){
    particleSystem = [];
    for (let i=0;i<PARTICLE_COUNT;i++){
      particleSystem.push({
        x: Math.random()*sketchW,
        y: Math.random()*sketchH,
        vx: 0,
        vy: 0,
        life: Math.random()*1000
      });
    }
  }

  let noiseZ = 0;
  function updateFlowField(){
    const scl = 20;
    let i = 0;
    for (let y=0;y<fieldRows;y++){
      for (let x=0;x<fieldCols;x++){
        const nx = x * 0.12;
        const ny = y * 0.12;
        // Perlin noise angle
        const a = noise(nx, ny, noiseZ) * Math.PI * 2 * 2; // more swirl
        field[i++] = a;
      }
    }
    noiseZ += 0.003;
  }

  function runParticles(){
    // particles follow field, leave faint trails (ghost)
    for (const p of particleSystem){
      const col = Math.floor(p.x / 20);
      const row = Math.floor(p.y / 20);
      const idx = Math.max(0, Math.min(field.length-1, row*fieldCols + col));
      const angle = field[idx] || 0;
      // acceleration
      const ax = Math.cos(angle) * 0.2;
      const ay = Math.sin(angle) * 0.2;
      p.vx = (p.vx + ax) * 0.95;
      p.vy = (p.vy + ay) * 0.95;
      p.x += p.vx;
      p.y += p.vy;
      // wrap
      if (p.x < 0) p.x = sketchW;
      if (p.x > sketchW) p.x = 0;
      if (p.y < 0) p.y = sketchH;
      if (p.y > sketchH) p.y = 0;
      // draw subtle particle point
      stroke(30, 30, 30, 80);
      strokeWeight(1.2);
      point(p.x, p.y);
    }
  }

  function draw() {
    // overlay draws on top of text; we want flowfield under drawing strokes but above text
    if (ghostMode) {
      // slight fade to produce trails
      push();
      noStroke();
      fill(255, 255, 255, 18); // fade to white slowly (acts as ghost trail)
      rect(0,0, width, height);
      pop();
    } else {
      clear(); // transparent clear so textarea shows through
    }

    // update and draw flowfield
    updateFlowField();
    // draw lightweight field as faint lines (optional)
    drawFieldLines();
    // run particles that follow the field
    runParticles();

    // drawing strokes: if mouse is pressed and drawingEnabled, draw lines and record points
    if (mouseIsPressed && drawingEnabled) {
      // ensure mouse is inside the canvas coordinates
      if (mouseX >= 0 && mouseX <= width && mouseY >= 0 && mouseY <= height) {
        stroke(0);
        strokeWeight(2);
        line(pmouseX, pmouseY, mouseX, mouseY);
        currentStroke.push({x: mouseX, y: mouseY});
      }
    }
  }

  function drawFieldLines(){
    stroke(200, 200, 200, 18);
    strokeWeight(1);
    const scl = 20;
    for (let y=0;y<fieldRows;y++){
      for (let x=0;x<fieldCols;x++){
        const i = y*fieldCols + x;
        const angle = field[i] || 0;
        const cx = x * scl + scl/2;
        const cy = y * scl + scl/2;
        const len = scl * 0.8;
        const x2 = cx + Math.cos(angle) * len;
        const y2 = cy + Math.sin(angle) * len;
        line(cx, cy, x2, y2);
      }
    }
  }

  function mouseReleased(){
    if (drawingEnabled && currentStroke.length > 0) {
      paths.push(currentStroke.slice());
      currentStroke = [];
    }
  }

  function keyPressed(){
    if (key === 'd' || key === 'D'){
      drawingEnabled = !drawingEnabled;
      document.getElementById('drawCanvas').style.pointerEvents = drawingEnabled ? 'auto' : 'none';
      document.getElementById('drawCanvas').style.cursor = drawingEnabled ? 'crosshair' : 'default';
    }
    if (key === 'g' || key === 'G'){
      toggleGhostMode();
    }
  }

  // clear drawing
  $id('clearDrawingBtn').addEventListener('click', ()=> {
    clear();
    // transparent background
    paths = [];
    currentStroke = [];
    // re-init (so particles keep moving)
    initFlowField();
    initParticles();
  });

  // ghost toggle (button)
  ghostToggle.addEventListener('click', toggleGhostMode);
  function toggleGhostMode(){
    ghostMode = !ghostMode;
    ghostToggle.textContent = ghostMode ? 'Ghost: On' : 'Ghost: Off';
    // ghostMode true => we allow trails via partial rect fill; drawing pointer-events unaffected
    // no further action required
  }

  // when window resizes, resize p5 canvas and recalc flowfield
  window.addEventListener('resize', () => {
    // delay slightly to ensure layout computed
    setTimeout(()=> {
      resizeSketchToWrap();
      initFlowField();
      initParticles();
      redrawDrawingFromPaths();
    }, 80);
  });

  function redrawDrawingFromPaths(){
    // redraw strokes onto current canvas
    // since p5 draw() continually runs, we'll draw paths once onto canvas using p5 API
    // erase current stroke overlay then replay
    clear();
    if (!ghostMode) {
      // clear transparent background
      clear();
    }
    stroke(0);
    strokeWeight(2);
    noFill();
    for (const strokePath of paths){
      if (strokePath.length < 2) continue;
      beginShape();
      for (const p of strokePath){
        vertex(p.x, p.y);
      }
      endShape();
    }
  }

  // ---------- EXPORTS ----------
  // TXT
  exportTxtBtn.addEventListener('click', ()=> {
    const blob = new Blob([notepad.value], { type:'text/plain;charset=utf-8' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'fadeaway.txt';
    a.click();
    URL.revokeObjectURL(a.href);
  });

  // PNG: we will render text onto a temporary canvas and draw p5 canvas on top (so transparent textarea works)
  exportPngBtn.addEventListener('click', async () => {
    // Create temp canvas
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = sketchW;
    exportCanvas.height = sketchH;
    const ctx = exportCanvas.getContext('2d');

    // white background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,exportCanvas.width, exportCanvas.height);

    // draw text (basic wrap)
    const textLines = notepad.value.split('\n');
    const fontSize = 16;
    ctx.fillStyle = '#000';
    ctx.font = `${fontSize}px ${notepad.style.fontFamily || 'IBMMonoCustom, monospace'}`;
    ctx.textBaseline = 'top';
    const lineHeight = Math.round(fontSize * 1.35);
    const padding = 20;
    let y = padding;
    for (let i=0;i<textLines.length;i++){
      const txt = textLines[i];
      // naive wrapping: if longer than width, break by characters (keeps it simple)
      if (ctx.measureText(txt).width <= exportCanvas.width - padding*2) {
        ctx.fillText(txt, padding, y);
        y += lineHeight;
      } else {
        // wrap
        let remaining = txt;
        while (remaining.length > 0 && y < exportCanvas.height - padding) {
          let fit = remaining;
          while (ctx.measureText(fit).width > exportCanvas.width - padding*2 && fit.length>1) fit = fit.slice(0, -1);
          ctx.fillText(fit, padding, y);
          remaining = remaining.slice(fit.length);
          y += lineHeight;
        }
      }
      if (y > exportCanvas.height - padding) break;
    }

    // draw p5 canvas content (drawing + flowfield)
    const p5canvas = document.querySelector('#drawCanvas canvas');
    if (p5canvas) {
      // draw current p5 pixels onto export canvas
      ctx.drawImage(p5canvas, 0, 0, exportCanvas.width, exportCanvas.height);
    }

    const a = document.createElement('a');
    a.href = exportCanvas.toDataURL('image/png');
    a.download = 'fadeaway.png';
    a.click();
  });

  // SVG: text as <text> plus stroke paths as vector <path>
  exportSvgBtn.addEventListener('click', () => {
    const width = sketchW;
    const height = sketchH;
    const lines = notepad.value.split('\n');
    const fontSize = 16;
    const lineHeight = Math.round(fontSize * 1.35);
    const padding = 20;

    function esc(t){
      return t.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&apos;');
    }

    let svg = `<?xml version="1.0" encoding="utf-8"?>\n`;
    svg += `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">\n`;
    svg += `<style>@font-face{font-family:IBMMonoCustom;src:url('https://raw.githubusercontent.com/ghostm68/inktwo/main/soviet-program/ibm-extended/IBMPlexMono-Medium.ttf');} text{font-family:IBMMonoCustom, monospace; font-size:${fontSize}px;}</style>\n`;
    svg += `<rect width="100%" height="100%" fill="white"/>\n`;
    svg += `<g fill="black" font-family="IBMMonoCustom" font-size="${fontSize}">\n`;
    for (let i=0;i<lines.length;i++){
      const y = padding + i*lineHeight;
      svg += `<text x="${padding}" y="${y}">${esc(lines[i])}</text>\n`;
    }
    svg += `</g>\n`;
    // strokes
    svg += `<g fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">\n`;
    for (const s of paths){
      if (!s || s.length === 0) continue;
      const d = s.map((p,i)=> (i===0 ? `M ${p.x} ${p.y}` : `L ${p.x} ${p.y}`)).join(' ');
      svg += `<path d="${d}"/>\n`;
    }
    svg += `</g>\n</svg>`;

    const blob = new Blob([svg], { type:'image/svg+xml;charset=utf-8' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'fadeaway.svg';
    a.click();
    URL.revokeObjectURL(a.href);
  });

  // ---------- DITHERING PANEL ----------
  const uploadInput = $id('uploadImage');
  const ditherCanvas = $id('ditherCanvas');
  const dCtx = ditherCanvas.getContext('2d');
  const algoSelect = $id('algoSelect');
  const paletteSelect = $id('paletteSelect');
  const scaleRange = $id('scaleRange');
  const scaleVal = $id('scaleVal');
  const thresholdRange = $id('thresholdRange');
  const thresholdVal = $id('thresholdVal');
  const applyDitherBtn = $id('applyDitherBtn');
  const downloadDitherBtn = $id('downloadDitherBtn');
  const resetDitherBtn = $id('resetDitherBtn');

  scaleVal.textContent = scaleRange.value;
  thresholdVal.textContent = thresholdRange.value;

  scaleRange.addEventListener('input', ()=> scaleVal.textContent = scaleRange.value );
  thresholdRange.addEventListener('input', ()=> thresholdVal.textContent = thresholdRange.value );

  let sourceImage = null;

  uploadInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const img = new Image();
    img.onload = () => {
      sourceImage = img;
      // set canvas size to image's natural size, but cap to width if very big
      const maxW = Math.min(img.width, 1200);
      const ratio = img.width > maxW ? maxW / img.width : 1;
      ditherCanvas.width = Math.round(img.width * ratio);
      ditherCanvas.height = Math.round(img.height * ratio);
      dCtx.imageSmoothingEnabled = false;
      dCtx.clearRect(0,0,ditherCanvas.width,ditherCanvas.height);
      dCtx.drawImage(img, 0, 0, ditherCanvas.width, ditherCanvas.height);
    };
    img.src = URL.createObjectURL(file);
  });

  applyDitherBtn.addEventListener('click', () => {
    if (!sourceImage) { alert('Please upload an image first.'); return; }
    dCtx.clearRect(0,0,ditherCanvas.width,ditherCanvas.height);
    dCtx.drawImage(sourceImage, 0, 0, ditherCanvas.width, ditherCanvas.height);
    applyDitherToCanvas();
  });

  resetDitherBtn.addEventListener('click', () => {
    if (sourceImage) {
      dCtx.clearRect(0,0,ditherCanvas.width,ditherCanvas.height);
      dCtx.drawImage(sourceImage, 0, 0, ditherCanvas.width, ditherCanvas.height);
    } else {
      dCtx.clearRect(0,0,ditherCanvas.width,ditherCanvas.height);
    }
  });

  downloadDitherBtn.addEventListener('click', () => {
    const a = document.createElement('a');
    a.href = ditherCanvas.toDataURL('image/png');
    a.download = 'fadeaway-dither.png';
    a.click();
  });

  function getImageDataCopy(){
    try {
      return dCtx.getImageData(0,0,ditherCanvas.width,ditherCanvas.height);
    } catch (e) {
      // security / tainted canvas
      alert('Unable to read pixels from this image (CORS). Try a local image or one from same origin.');
      throw e;
    }
  }

  function applyDitherToCanvas(){
    const algo = algoSelect.value;
    const palette = paletteSelect.value;
    const displayScale = parseInt(scaleRange.value,10) || 1;
    const threshold = parseInt(thresholdRange.value,10) || 128;

    const src = getImageDataCopy();
    const w = src.width, h = src.height;
    const lum = new Float32Array(w*h);
    for (let i=0;i<w*h;i++){
      const di = i*4;
      const r = src.data[di], g = src.data[di+1], b = src.data[di+2];
      lum[i] = 0.299*r + 0.587*g + 0.114*b;
    }

    const out = new Uint8ClampedArray(w*h*4);

    if (algo === 'threshold') {
      for (let i=0;i<w*h;i++){
        const v = lum[i] < threshold ? 0 : 255;
        writeOutTo(out, i, v, palette);
      }
    } else if (algo === 'random') {
      for (let i=0;i<w*h;i++){
        const v = (lum[i] < Math.random()*255) ? 0 : 255;
        writeOutTo(out, i, v, palette);
      }
    } else if (algo === 'bayer') {
      const bayer = [
        [0,  8,  2, 10],
        [12, 4, 14, 6],
        [3, 11, 1, 9],
        [15, 7, 13, 5]
      ];
      for (let y=0;y<h;y++){
        for (let x=0;x<w;x++){
          const i = y*w + x;
          const m = bayer[y%4][x%4] / 16;
          const val = lum[i] / 255;
          const v = (val < m) ? 0 : 255;
          writeOutTo(out, i, v, palette);
        }
      }
    } else if (algo === 'floyd') {
      const buf = new Float32Array(lum);
      for (let y=0;y<h;y++){
        for (let x=0;x<w;x++){
          const idx = y*w + x;
          const oldv = buf[idx];
          const newv = oldv < threshold ? 0 : 255;
          const err = oldv - newv;
          writeOutTo(out, idx, newv, palette);
          if (x+1 < w) buf[idx+1] += err * 7/16;
          if (x-1 >=0 && y+1<h) buf[idx + w -1] += err * 3/16;
          if (y+1 < h) buf[idx + w] += err * 5/16;
          if (x+1 < w && y+1 < h) buf[idx + w +1] += err * 1/16;
        }
      }
    } else if (algo === 'atkinson') {
      const buf = new Float32Array(lum);
      for (let y=0;y<h;y++){
        for (let x=0;x<w;x++){
          const idx = y*w + x;
          const oldv = buf[idx];
          const newv = oldv < threshold ? 0 : 255;
          const err = (oldv - newv) / 8;
          writeOutTo(out, idx, newv, palette);
          distribute(buf, x+1,y,w,h,err);
          distribute(buf, x+2,y,w,h,err);
          distribute(buf, x-1,y+1,w,h,err);
          distribute(buf, x,y+1,w,h,err);
          distribute(buf, x+1,y+1,w,h,err);
          distribute(buf, x,y+2,w,h,err);
        }
      }
    }

    // create imageData and draw scaled for preview
    const imgOut = new ImageData(out, w, h);
    const tmp = document.createElement('canvas');
    tmp.width = w; tmp.height = h;
    const tCtx = tmp.getContext('2d');
    tCtx.putImageData(imgOut, 0, 0);

    dCtx.imageSmoothingEnabled = false;
    ditherCanvas.width = w * displayScale;
    ditherCanvas.height = h * displayScale;
    dCtx.clearRect(0,0,ditherCanvas.width,ditherCanvas.height);
    dCtx.drawImage(tmp, 0, 0, ditherCanvas.width, ditherCanvas.height);
  }

  function writeOutTo(outArr, i, v, palette){
    let r,g,b;
    if (palette === 'bw') {
      r = g = b = v < 128 ? 0 : 255;
    } else if (palette === 'grayscale') {
      r = g = b = Math.round(v);
    } else if (palette === '4level') {
      let level;
      if (v < 64) level = 0;
      else if (v < 128) level = 85;
      else if (v < 192) level = 170;
      else level = 255;
      r = g = b = level;
    } else {
      r = g = b = v;
    }
    const base = i*4;
    outArr[base] = r; outArr[base+1] = g; outArr[base+2] = b; outArr[base+3] = 255;
  }

  function distribute(buf, x, y, w, h, err){
    if (x < 0 || x >= w || y < 0 || y >= h) return;
    const pos = y*w + x;
    buf[pos] += err;
  }

  // ---------- INIT ----------
  // p5 auto-invokes setup(); we must ensure DOM ready
  (function readyInit(){
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        // Delay a touch so p5 can attach its canvas properly
        setTimeout(()=> {
          // p5 will call setup(); we also ensure fonts are applied
          notepad.style.fontFamily = fontSelect.value;
        }, 50);
      });
    } else {
      setTimeout(()=> { notepad.style.fontFamily = fontSelect.value; }, 20);
    }
  })();

  // Expose small console-friendly messages
  console.log('Fadeaway script loaded — ready for interaction.');

  </script>
</body>
</html>
