<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Typewriter Editor</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=Special+Elite&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: linear-gradient(to bottom right, #292524, #1c1917, #000);
      color: white;
      overflow: hidden;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Typewriter Container */
    .typewriter-container {
      position: relative;
      width: 90%;
      max-width: 800px;
      margin: 0 auto;
    }

    /* Text Area - Adjusted to align with paper */
  /* Hidden textarea for animated typewriter */
#text-input {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0; /* Makes it invisible but functional */
  z-index: 100; /* Above everything so it can receive typing */
  cursor: text;
  background: transparent;
  border: none;
  outline: none;
  resize: none;
  font-family: 'Courier New', monospace;
  font-size: 14px;
  line-height: 1.6;
  padding: 0;
  margin: 0;
  caret-color: #000; /* Visible cursor */
}

/* Make sure the typewriter container is positioned */
.typewriter-container {
  position: relative;
  width: 90%;
  max-width: 800px;
  margin: 0 auto;
}

    /* Status Bar */
    .status-bar {
      margin-top: 1.5rem;
      text-align: center;
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.75rem;
      background: rgba(41, 37, 36, 0.8);
      backdrop-filter: blur(10px);
      padding: 0.75rem 1.5rem;
      border-radius: 9999px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.3);
      border: 1px solid #57534e;
    }

    .status-text {
      font-size: 0.875rem;
      color: #d6d3d1;
    }

    /* Debug overlay (visible with Ctrl+D) */
    .debug-overlay {
      position: absolute;
      border: 2px solid red;
      background: rgba(255, 0, 0, 0.1);
      z-index: 5;
      display: none;
      pointer-events: none;
    }

    /* Position adjustment controls (for fine-tuning) */
    .position-controls {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 8px;
      z-index: 100;
      display: none; /* Hidden by default */
    }

    .position-controls.visible {
      display: block;
    }
    /* Notepad Styles */
.notepad-container {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 300px;
  background: rgba(15, 15, 15, 0.95);
  border: 1px solid #444;
  border-radius: 4px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
  font-family: 'Special Elite', 'Courier New', monospace;
  z-index: 1000;
  backdrop-filter: blur(10px);
}

.notepad-header {
  background: rgba(0, 0, 0, 0.8);
  padding: 8px 12px;
  border-bottom: 1px solid #444;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.notepad-title {
  color: #ffd700;
  font-size: 12px;
  letter-spacing: 2px;
  text-transform: uppercase;
  font-weight: bold;
}

.notepad-toggle {
  background: transparent;
  border: none;
  color: #ccc;
  cursor: pointer;
  font-size: 16px;
  padding: 2px 8px;
  border-radius: 3px;
}

.notepad-toggle:hover {
  background: rgba(255, 255, 255, 0.1);
}

.notepad-content {
  padding: 12px;
}

.notepad-textarea {
  width: 100%;
  height: 200px;
  background: transparent;
  color: #0f0;
  font-family: 'Special Elite', 'Courier New', monospace;
  font-size: 13px;
  line-height: 1.4;
  border: none;
  outline: none;
  resize: none;
  overflow-y: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.notepad-textarea:empty:before {
  content: attr(placeholder);
  color: #666;
}

.notepad-status {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
  font-size: 11px;
  color: #888;
  border-top: 1px solid #333;
  padding-top: 8px;
}

.notepad-textarea::selection {
  background: rgba(0, 255, 0, 0.3);
}
    /* Background Video */
#background-video {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  z-index: -1;
}
/* Animated Typewriter */
.typewriter-machine {
  width: 800px;
  max-width: 90%;
  margin: 0 auto;
  position: relative;
}

.typewriter-body {
  background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
  border-radius: 15px 15px 8px 8px;
  padding: 30px 40px 20px;
  box-shadow: 
    0 20px 40px rgba(0,0,0,0.5),
    inset 0 1px 0 rgba(255,255,255,0.1);
  position: relative;
  border: 1px solid #444;
}

.typewriter-top {
  background: #222;
  height: 20px;
  border-radius: 5px 5px 0 0;
  margin-bottom: 25px;
  position: relative;
  border-bottom: 2px solid #333;
}

.typewriter-brand {
  position: absolute;
  top: 2px;
  left: 20px;
  color: #aaa;
  font-size: 10px;
  font-family: 'Courier New', monospace;
  letter-spacing: 2px;
  text-transform: uppercase;
}

.typewriter-platen {
  position: absolute;
  top: 5px;
  right: 20px;
  width: 60px;
  height: 10px;
  background: #444;
  border-radius: 2px;
}

/* Paper Roll */
.paper-roll {
  background: #f5f5f0;
  height: 180px;
  border-radius: 3px;
  position: relative;
  margin-bottom: 20px;
  box-shadow: 
    inset 0 0 10px rgba(0,0,0,0.1),
    0 2px 4px rgba(0,0,0,0.2);
  overflow: hidden;
  border: 1px solid #ddd;
}

.paper-tear {
  position: absolute;
  top: -5px;
  left: 10px;
  right: 10px;
  height: 5px;
  background: #f5f5f0;
  border-radius: 50%;
  opacity: 0.7;
}

.paper-sheet {
  position: absolute;
  top: 10px;
  left: 15px;
  right: 15px;
  bottom: 30px;
  background: #fff;
  padding: 15px;
  font-family: 'Courier New', monospace;
  font-size: 14px;
  line-height: 1.6;
  color: #000;
  overflow: hidden;
}

.paper-content {
  height: 100%;
  white-space: pre-wrap;
  word-wrap: break-word;
  font-weight: 500;
}

.paper-roll-bottom {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 30px;
  background: repeating-linear-gradient(
    to bottom,
    #f5f5f0,
    #f5f5f0 5px,
    #e0e0d0 5px,
    #e0e0d0 10px
  );
  border-top: 1px solid #ddd;
}

/* Typewriter Keys */
.typewriter-keys {
  display: flex;
  flex-direction: column;
  gap: 8px;
  position: relative;
  z-index: 2;
}

.key-row {
  display: flex;
  justify-content: center;
  gap: 4px;
}

.key {
  width: 40px;
  height: 35px;
  background: linear-gradient(to bottom, #444, #222);
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #ccc;
  font-family: 'Courier New', monospace;
  font-size: 12px;
  font-weight: bold;
  box-shadow: 
    0 2px 0 #111,
    inset 0 1px 0 rgba(255,255,255,0.1);
  cursor: pointer;
  user-select: none;
  transition: all 0.1s;
  position: relative;
}

.key:active {
  transform: translateY(2px);
  box-shadow: 
    0 0 0 #111,
    inset 0 1px 0 rgba(255,255,255,0.1);
  background: linear-gradient(to bottom, #333, #111);
}

.key.shift {
  width: 60px;
  font-size: 14px;
  color: #888;
}

.key.return {
  width: 60px;
  font-size: 16px;
  color: #4a9;
}

.key.spacebar {
  width: 280px;
  height: 25px;
  margin-top: 5px;
}

/* Carriage */
.carriage {
  position: absolute;
  top: 50px;
  left: 15px;
  width: 5px;
  height: 190px;
  background: linear-gradient(to bottom, #666, #333);
  border-radius: 2px;
  transition: left 0.3s ease;
  z-index: 1;
  box-shadow: 0 0 10px rgba(0,0,0,0.3);
}

.carriage:before {
  content: '';
  position: absolute;
  top: 0;
  left: -5px;
  width: 15px;
  height: 10px;
  background: #555;
  border-radius: 2px;
}

/* Status Bar */
.status-badge {
  display: flex;
  justify-content: center;
  gap: 30px;
  align-items: center;
  background: rgba(41, 37, 36, 0.8);
  backdrop-filter: blur(10px);
  padding: 0.75rem 1.5rem;
  border-radius: 9999px;
  box-shadow: 0 10px 25px rgba(0,0,0,0.3);
  border: 1px solid #57534e;
  margin-top: 30px;
}  
 /* WebLLM Chat Panel */
.chat-panel {
  position: fixed;
  top: 20px;
  left: 20px;
  width: 320px;
  background: rgba(15, 15, 15, 0.95);
  border: 1px solid #444;
  border-radius: 4px;
  font-family: 'IBM Plex Mono', 'Courier New', monospace;
  z-index: 1000;
  backdrop-filter: blur(10px);
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
}

.chat-header {
  background: rgba(0, 0, 0, 0.8);
  padding: 8px 12px;
  border-bottom: 1px solid #444;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.chat-title {
  color: #00ffff;
  font-size: 12px;
  letter-spacing: 2px;
  text-transform: uppercase;
  font-weight: bold;
  text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
}

.chat-toggle {
  background: transparent;
  border: none;
  color: #ccc;
  cursor: pointer;
  font-size: 16px;
  padding: 2px 8px;
  border-radius: 3px;
}

.chat-toggle:hover {
  background: rgba(255, 255, 255, 0.1);
}

.chat-content {
  padding: 12px;
}

.model-status {
  background: rgba(0, 20, 40, 0.8);
  border: 1px solid #003355;
  border-radius: 3px;
  padding: 8px;
  margin-bottom: 12px;
  font-size: 11px;
}

.status-line {
  display: flex;
  align-items: center;
  margin-bottom: 4px;
}

.status-label {
  color: #00aaff;
  min-width: 60px;
}

.status-value {
  color: #0f0;
  margin-left: 8px;
  font-weight: bold;
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-left: 8px;
  background: #f00;
}

.status-dot.online {
  background: #0f0;
  box-shadow: 0 0 8px #0f0;
}

.download-section {
  background: rgba(20, 0, 0, 0.8);
  border: 1px solid #550000;
  border-radius: 3px;
  padding: 8px;
  margin-bottom: 12px;
}

.download-header {
  display: flex;
  justify-content: space-between;
  font-size: 10px;
  margin-bottom: 4px;
}

.download-label {
  color: #ff4444;
}

.download-percent {
  color: #ffaa00;
  font-weight: bold;
}

.progress-bar {
  width: 100%;
  height: 3px;
  background: #222;
  border-radius: 2px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #ff0033, #ff5500);
  width: 0%;
  transition: width 0.3s;
}

.chat-messages {
  height: 300px;
  overflow-y: auto;
  background: rgba(0, 0, 0, 0.7);
  border: 1px solid #333;
  border-radius: 3px;
  padding: 8px;
  margin-bottom: 12px;
  font-size: 11px;
  line-height: 1.4;
}

.empty-message {
  color: #666;
  font-style: italic;
  text-align: center;
  padding: 20px;
}

.message {
  margin-bottom: 8px;
}

.user-message {
  color: #00aaff;
}

.ai-message {
  color: #0f0;
}

.chat-input-section {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

#llm-input {
  width: 100%;
  background: rgba(0, 0, 0, 0.8);
  color: #0f0;
  border: 1px solid #444;
  border-radius: 3px;
  padding: 8px;
  font-family: 'IBM Plex Mono', 'Courier New', monospace;
  font-size: 11px;
  resize: none;
  outline: none;
}

#llm-input:focus {
  border-color: #00aaff;
}

.chat-controls {
  display: flex;
  gap: 8px;
}

.send-button, .load-button {
  flex: 1;
  padding: 6px;
  border: none;
  border-radius: 3px;
  font-family: 'IBM Plex Mono', monospace;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 1px;
  cursor: pointer;
  transition: all 0.2s;
}

.send-button {
  background: #003355;
  color: #00aaff;
}

.send-button:hover:not(:disabled) {
  background: #004477;
}

.load-button {
  background: #330000;
  color: #ff4444;
}

.load-button:hover:not(:disabled) {
  background: #550000;
}

.send-button:disabled, .load-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}   
  </style>
</head>
<body>
  <body>
  <!-- Background Video -->
  <video id="background-video" autoplay muted loop playsinline>
    <source src="https://assets.mixkit.co/videos/preview/mixkit-typing-on-a-vintage-typewriter-close-up-4094-large.mp4" type="video/mp4">
    <!-- Add fallback image if video doesn't load -->
    <img src="https://raw.githubusercontent.com/ghostm68/pantheon/main/satellite.jpg" alt="Fallback background" style="width: 100%; height: 100%; object-fit: cover;">
  </video>
  <!-- Left-side WebLLM Chat Panel -->
<div class="chat-panel" id="chat-panel">
  <div class="chat-header">
    <span class="chat-title">WEBLLM TERMINAL</span>
    <button class="chat-toggle" id="chat-toggle">üí¨</button>
  </div>
  
  <div class="chat-content">
    <!-- Model Status -->
    <div class="model-status" id="model-status">
      <div class="status-line">
        <span class="status-label">MODEL:</span>
        <span class="status-value" id="current-model">Qwen2.5-0.5B</span>
      </div>
      <div class="status-line">
        <span class="status-label">STATUS:</span>
        <span class="status-value" id="llm-status">OFFLINE</span>
        <span class="status-dot" id="llm-dot"></span>
      </div>
    </div>
    
    <!-- Download Progress -->
    <div class="download-section" id="download-section" style="display: none;">
      <div class="download-header">
        <span class="download-label">SYNCING WEIGHTS</span>
        <span class="download-percent" id="progress-percent">0%</span>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" id="progress-bar"></div>
      </div>
    </div>
    
    <!-- Chat Messages -->
    <div class="chat-messages" id="llm-chat-messages">
      <div class="empty-message">// Local neural interface ready</div>
    </div>
    
    <!-- Chat Input -->
    <div class="chat-input-section">
      <textarea 
        id="llm-input" 
        placeholder="Query local neural core..."
        rows="2"
      ></textarea>
      <div class="chat-controls">
        <button id="send-llm" class="send-button">SEND</button>
        <button id="loadCoreBtn" class="load-button">ACTIVATE</button>
      </div>
    </div>
  </div>
</div>
  <!-- Rest of your code continues here -->
<div class="typewriter-container">
  <div class="typewriter-machine">
    <!-- Typewriter Body -->
    <div class="typewriter-body">
      <div class="typewriter-top">
        <div class="typewriter-brand">INK REALM</div>
        <div class="typewriter-platen"></div>
      </div>
      
      <!-- Paper Roll Area -->
      <div class="paper-roll">
        <div class="paper-tear"></div>
        <div class="paper-sheet">
          <!-- This shows only 5 lines at a time -->
          <div class="paper-content" id="paper-display"></div>
        </div>
        <div class="paper-roll-bottom"></div>
      </div>
      
      <!-- Typewriter Keys -->
      <div class="typewriter-keys">
        <div class="key-row">
          <div class="key">Q</div><div class="key">W</div><div class="key">E</div><div class="key">R</div>
          <div class="key">T</div><div class="key">Y</div><div class="key">U</div><div class="key">I</div>
          <div class="key">O</div><div class="key">P</div>
        </div>
        <div class="key-row">
          <div class="key">A</div><div class="key">S</div><div class="key">D</div><div class="key">F</div>
          <div class="key">G</div><div class="key">H</div><div class="key">J</div><div class="key">K</div>
          <div class="key">L</div>
        </div>
        <div class="key-row">
          <div class="key shift">‚Üë</div>
          <div class="key">Z</div><div class="key">X</div><div class="key">C</div><div class="key">V</div>
          <div class="key">B</div><div class="key">N</div><div class="key">M</div>
          <div class="key return">‚Üµ</div>
        </div>
        <div class="key-row">
          <div class="key spacebar"></div>
        </div>
      </div>
      
      <!-- Carriage (moves as you type) -->
      <div class="carriage" id="carriage"></div>
    </div>
  </div>

  <!-- Hidden textarea for actual input -->
  <textarea 
    id="text-input" 
    placeholder="Start typing..."
    spellcheck="false"
    style="opacity: 0; position: absolute; left: -9999px;"
  ></textarea>

  <div class="status-bar">
    <div class="status-badge">
      <span class="status-text" id="char-count">0 characters</span>
      <span class="status-text" id="line-count">Line: 1</span>
    </div>
  </div>
</div>

  <script>
// ========== ANIMATED TYPEWRITER ==========
class AnimatedTypewriter {
  constructor() {
    this.textInput = document.getElementById('text-input');
    this.paperDisplay = document.getElementById('paper-display');
    this.carriage = document.getElementById('carriage');
    this.charCount = document.getElementById('char-count');
    this.lineCount = document.getElementById('line-count');
    
    this.maxVisibleLines = 5;
    this.carriagePosition = 0;
    this.maxCarriage = 95;
    
    this.init();
  }
  
  init() {
    this.textInput.addEventListener('input', () => this.updateDisplay());
    this.textInput.addEventListener('keydown', (e) => this.handleKeyPress(e));
    this.textInput.focus();
    
    // Initialize
    this.updateDisplay();
  }
  
  updateDisplay() {
    const text = this.textInput.value;
    
    // Update character count
    this.charCount.textContent = `${text.length} characters`;
    
    // Split into lines and show only last 5
    const lines = text.split('\n');
    const visibleLines = lines.slice(-this.maxVisibleLines);
    this.paperDisplay.textContent = visibleLines.join('\n');
    
    // Update line count
    this.lineCount.textContent = `Line: ${lines.length}`;
    
    // Update carriage position
    const lastLine = lines[lines.length - 1] || '';
    this.carriagePosition = Math.min(this.maxCarriage, (lastLine.length / 80) * 100);
    this.updateCarriage();
  }
  
  updateCarriage() {
    // Calculate carriage position (15px to 680px range)
    const minLeft = 15;
    const maxLeft = 680;
    const leftPos = minLeft + (this.carriagePosition / 100) * (maxLeft - minLeft);
    this.carriage.style.left = `${leftPos}px`;
  }
  
  handleKeyPress(event) {
    // Animate carriage return on Enter
    if (event.key === 'Enter') {
      this.animateCarriageReturn();
    }
    
    // Find and animate key if it's a letter
    if (event.key.length === 1 && event.key.match(/[a-z]/i)) {
      this.animateKeyPress(event.key.toUpperCase());
    }
  }
  
  animateCarriageReturn() {
    // Reset carriage to left
    this.carriage.style.transition = 'left 0.5s ease';
    this.carriage.style.left = '15px';
    
    setTimeout(() => {
      this.carriage.style.transition = 'left 0.3s ease';
    }, 500);
  }
  
  animateKeyPress(keyChar) {
    // Find the key element
    const keys = document.querySelectorAll('.key:not(.shift):not(.return):not(.spacebar)');
    const keyElement = Array.from(keys).find(k => k.textContent === keyChar);
    
    if (keyElement) {
      keyElement.classList.add('pressed');
      setTimeout(() => keyElement.classList.remove('pressed'), 100);
    }
  }
}

// Initialize the animated typewriter
const typewriter = new AnimatedTypewriter();

// ========== NOTEPAD TOGGLE ==========
const notepadToggle = document.getElementById('notepad-toggle');
const notepadContainer = document.getElementById('notepad-container');

if (notepadToggle && notepadContainer) {
    notepadToggle.addEventListener('click', () => {
        const isHidden = notepadContainer.style.display === 'none';
        notepadContainer.style.display = isHidden ? 'block' : 'none';
        notepadToggle.textContent = isHidden ? 'üìù' : 'üìã';
    });
    
    // Optional: Toggle notepad with Ctrl+N
    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key === 'n') {
            e.preventDefault();
            notepadToggle.click();
        }
    });
}

// ========== AUTO-FOCUS TEXTAREA ON PAGE LOAD ==========
window.addEventListener('load', () => {
  setTimeout(() => {
    document.getElementById('text-input').focus();
  }, 500);
});
  </script>
    <!-- Notepad Sidebar -->
<div class="notepad-container" id="notepad-container">
  <div class="notepad-header">
    <span class="notepad-title">NOTEPAD</span>
    <button class="notepad-toggle" id="notepad-toggle">üìù</button>
  </div>
  <div class="notepad-content">
    <div class="notepad-textarea" id="notepad-textarea" contenteditable="true" spellcheck="false" placeholder="Notes..."></div>
    <div class="notepad-status">
      <span id="notepad-char-count">0 chars</span>
      <span id="notepad-status">‚óè</span>
    </div>
  </div>
</div>
    <script>
      // ========== NOTEPAD AUTO-SAVE ==========
(function() {
    const notepad = document.getElementById('notepad-textarea');
    const notepadCharCount = document.getElementById('notepad-char-count');
    const notepadStatus = document.getElementById('notepad-status');
    
    if (!notepad) return;

    // Event listeners
    notepad.addEventListener('input', debounce(500, saveNotepad));
    window.addEventListener('DOMContentLoaded', loadNotepad);
    window.addEventListener('hashchange', loadNotepad);
    
    // Update character count
    notepad.addEventListener('input', () => {
        notepadCharCount.textContent = `${notepad.textContent.length} chars`;
    });

    // Load notepad from URL or localStorage
    async function loadNotepad() {
        try {
            if (location.hash !== '') {
                const params = new URLSearchParams(location.hash.slice(1));
                const noteHash = params.get('note');
                if (noteHash) await setNotepad(noteHash);
            } else {
                const saved = localStorage.getItem('notepad-hash');
                if (saved) await setNotepad(saved);
            }
        } catch (e) {
            console.log('No notepad loaded');
        }
    }

    // Save notepad to URL and localStorage
    async function saveNotepad() {
        const hash = await getNotepadHash();
        
        try { 
            localStorage.setItem('notepad-hash', hash);
            notepadStatus.textContent = '‚úì Saved';
            notepadStatus.style.color = '#0f0';
            
            // Clear status after 2 seconds
            setTimeout(() => {
                notepadStatus.textContent = '‚óè';
                notepadStatus.style.color = '#888';
            }, 2000);
        } catch (e) {
            notepadStatus.textContent = '‚úó Error';
            notepadStatus.style.color = '#f00';
        }
        
        // Update URL hash with both article and notepad
        const currentHash = new URLSearchParams(location.hash.slice(1) || '');
        currentHash.set('note', hash);
        const newHash = currentHash.toString();
        
        if (location.hash !== `#${newHash}`) {
            history.replaceState({}, '', `#${newHash}`);
        }
    }

    // Set notepad content from hash
    async function setNotepad(hash) {
        const content = await decompressNotepad(hash);
        notepad.textContent = content;
        notepadCharCount.textContent = `${content.length} chars`;
    }

    // Get hash from notepad content
    async function getNotepadHash() {
        const content = notepad.textContent;
        return await compressNotepad(content);
    }

    // Compress notepad content
    async function compressNotepad(string) {
        const byteArray = new TextEncoder().encode(string);
        const stream = new CompressionStream('deflate-raw');
        const writer = stream.writable.getWriter();
        writer.write(byteArray);
        writer.close();
        const buffer = await new Response(stream.readable).arrayBuffer();
        return btoa(String.fromCharCode(...new Uint8Array(buffer)))
            .replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    }

    // Decompress notepad content
    async function decompressNotepad(b64) {
        const byteArray = Uint8Array.from(
            atob(b64.replace(/-/g, "+").replace(/_/g, "/")), 
            c => c.charCodeAt(0)
        );
        const stream = new DecompressionStream('deflate-raw');
        const writer = stream.writable.getWriter();
        writer.write(byteArray);
        writer.close();
        const buffer = await new Response(stream.readable).arrayBuffer();
        return new TextDecoder().decode(buffer);
    }

    // Debounce helper
    function debounce(ms, fn) {
        let timer;
        return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => fn(...args), ms);
        };
    }
})();

// ========== MAIN TEXTAREA AUTO-SAVE (OPTIONAL) ==========
// If you want the main textarea to also auto-save, add this:
(function() {
    const mainTextarea = document.getElementById('text-input');
    if (!mainTextarea) return;

    // Debounced save function
    const saveMainContent = debounce(1000, () => {
        const content = mainTextarea.value;
        localStorage.setItem('main-content', content);
        console.log('Main content saved');
    });

    // Load on startup
    window.addEventListener('DOMContentLoaded', () => {
        const saved = localStorage.getItem('main-content');
        if (saved) {
            mainTextarea.value = saved;
            charCount.textContent = `${saved.length} characters`;
        }
    });

    // Save on input
    mainTextarea.addEventListener('input', saveMainContent);

    function debounce(ms, fn) {
        let timer;
        return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => fn(...args), ms);
        };
    }
})();
    </script>
    <script>
      // ========== WEBLLM CHAT PANEL ==========
class InkRealmTerminal {
    constructor() {
        this.engine = undefined;
        this.isGenerating = false;
        this.currentModel = 'qwen-tiny';
        this.modelName = 'Qwen2.5-0.5B-Instruct-q4f16_1-MLC';
        
        this.systemPrompt = "You are the INK REALM Neural Interface. Gritty, 1980s literary terminal aesthetic. Sharp prose.";
        this.init();
    }

    init() {
        this.setupEvents();
        this.updateStatus('OFFLINE');
    }

    setupEvents() {
        const sendBtn = document.getElementById('send-llm');
        const loadBtn = document.getElementById('loadCoreBtn');
        const chatInput = document.getElementById('llm-input');
        
        if (sendBtn) {
            sendBtn.addEventListener('click', () => this.sendMessage());
        }
        
        if (loadBtn) {
            loadBtn.addEventListener('click', () => this.loadModel());
        }
        
        if (chatInput) {
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });
        }
    }

    updateStatus(status, isOnline = false) {
        const statusEl = document.getElementById('llm-status');
        const dotEl = document.getElementById('llm-dot');
        
        if (statusEl) statusEl.textContent = status;
        if (dotEl) {
            dotEl.textContent = isOnline ? '‚óè' : '‚óã';
            dotEl.className = isOnline ? 'status-dot online' : 'status-dot';
        }
    }

    showProgress(percent) {
        const progressSection = document.getElementById('download-section');
        const progressBar = document.getElementById('progress-bar');
        const progressPercent = document.getElementById('progress-percent');
        
        if (progressSection) progressSection.style.display = 'block';
        if (progressBar) progressBar.style.width = `${percent}%`;
        if (progressPercent) progressPercent.textContent = `${Math.round(percent)}%`;
    }

    hideProgress() {
        const progressSection = document.getElementById('download-section');
        if (progressSection) progressSection.style.display = 'none';
    }

    async loadModel() {
        if (this.engine) {
            this.addMessage('system', 'Model already loaded');
            return;
        }

        this.updateStatus('LOADING...');
        this.showProgress(0);
        
        try {
            // Import WebLLM
            const { CreateMLCEngine } = await import("https://esm.run/@mlc-ai/web-llm@0.2.79");
            
            this.engine = await CreateMLCEngine(this.modelName, {
                initProgressCallback: (report) => {
                    const percent = report.progress * 100;
                    this.showProgress(percent);
                }
            });

            this.hideProgress();
            this.updateStatus('ONLINE', true);
            this.addMessage('system', `// Neural core activated: ${this.modelName}`);
            
        } catch (error) {
            console.error('Failed to load model:', error);
            this.updateStatus('ERROR');
            this.addMessage('system', `// Error: ${error.message}`);
            this.hideProgress();
        }
    }

    async sendMessage() {
        const inputEl = document.getElementById('llm-input');
        const sendBtn = document.getElementById('send-llm');
        
        if (!inputEl || !this.engine || this.isGenerating) return;
        
        const message = inputEl.value.trim();
        if (!message) return;
        
        // Add user message
        this.addMessage('user', message);
        inputEl.value = '';
        
        // Disable input while generating
        this.isGenerating = true;
        if (sendBtn) sendBtn.disabled = true;
        
        try {
            const messages = [
                { role: 'system', content: this.systemPrompt },
                { role: 'user', content: message }
            ];
            
            const reply = await this.engine.chat.completions.create({
                messages: messages,
                temperature: 0.7,
                max_tokens: 500,
            });
            
            const response = reply.choices[0]?.message?.content || 'No response';
            this.addMessage('ai', response);
            
        } catch (error) {
            console.error('Generation error:', error);
            this.addMessage('system', `// Error: ${error.message}`);
        } finally {
            this.isGenerating = false;
            if (sendBtn) sendBtn.disabled = false;
            if (inputEl) inputEl.focus();
        }
    }

    addMessage(role, content) {
        const messagesContainer = document.getElementById('llm-chat-messages');
        if (!messagesContainer) return;
        
        // Remove empty message if present
        const emptyMsg = messagesContainer.querySelector('.empty-message');
        if (emptyMsg) emptyMsg.remove();
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${role === 'user' ? 'user-message' : 'ai-message'}`;
        
        const prefix = role === 'user' ? '> ' : role === 'ai' ? '// ' : '::: ';
        messageDiv.textContent = `${prefix}${content}`;
        
        messagesContainer.appendChild(messageDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
}

// Initialize WebLLM terminal
const llmTerminal = new InkRealmTerminal();

// Chat panel toggle
const chatToggle = document.getElementById('chat-toggle');
const chatPanel = document.getElementById('chat-panel');

if (chatToggle && chatPanel) {
    chatToggle.addEventListener('click', () => {
        const isHidden = chatPanel.style.display === 'none';
        chatPanel.style.display = isHidden ? 'block' : 'none';
        chatToggle.textContent = isHidden ? 'üí¨' : 'ü§ñ';
    });
    
    // Toggle with Ctrl+L
    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key === 'l') {
            e.preventDefault();
            chatToggle.click();
        }
    });
}
    </script>
</body>
</html>
