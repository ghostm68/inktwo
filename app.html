<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>INK REALM | AI Writing Terminal</title>
    
    <!-- Meta Data -->
    <meta name="description" content="INK REALM | AI Writing Terminal. A monochrome neural interface for creative writing and text generation powered by Google's Gemini & Gemma models via Puter.js. Cyberpunk writing environment with minimalist aesthetics.">
    <meta name="keywords" content="AI writing, creative writing, Google Gemini, Gemma models, Puter.js, cyberpunk writing, text generation, neural interface, black and white aesthetic, writing assistant, AI author, creative writing app">
    <meta name="author" content="INKREALM-NEXUS">
    <meta name="copyright" content="Copyright 2026 INKREALM-NEXUS. All rights reserved.">
    <meta name="robots" content="index, follow">

    <!-- OPEN GRAPH -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://inkrealm.info/app">
    <meta property="og:title" content="INK REALM | AI Writing Terminal">
    <meta property="og:description" content="A monochrome neural writing interface powered by Google Gemini & Gemma models. Creative writing, text generation, and literary exploration in a cyberpunk aesthetic.">
    <meta property="og:image" content="https://github.com/ghostm68/pantheon/raw/main/mw.inkrealm.info.webp">
    <meta property="og:image:alt" content="INK REALM AI Writing Terminal Interface">
    <meta property="og:site_name" content="INK REALM AI Writing Terminal">
    <meta property="og:locale" content="en_US">

    <!-- TWITTER / X -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@inkrealm">
    <meta name="twitter:creator" content="@inkrealm">
    <meta name="twitter:title" content="INK REALM AI Writing Terminal">
    <meta name="twitter:description" content="Monochrome AI writing interface using Google Gemini 2.5 & Gemma models. Creative writing, prose generation, and literary AI. Powered by Puter.js">
    <meta name="twitter:image" content="https://github.com/ghostm68/pantheon/raw/main/mw.inkrealm.info.webp">

    <!-- MOBILE APP STYLING -->
    <meta name="theme-color" content="#000000">
    <meta name="msapplication-navbutton-color" content="#000000">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-capable" content="yes">
    
    <!-- PuterJS SDK -->
    <script src="https://js.puter.com/v2/"></script>
    
     <style>
        /* --- RESET & BASE --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'IBM Plex Mono', 'Courier New', monospace;
            background: #050505;
            color: #ccc;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- SPLASH SCREEN --- */
        .glitch-splash {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            pointer-events: none;
        }
        
        .splash-logo-container {
            position: relative;
            margin-bottom: 2rem;
            animation: float 4s ease-in-out infinite;
        }

        .splash-image {
            width: 120px;
            filter: grayscale(100%) contrast(1.2) drop-shadow(0 0 10px rgba(255,255,255,0.3));
            animation: glitch-anim 3s infinite linear alternate-reverse;
        }

        .glitch-text {
            font-size: 1.5rem;
            letter-spacing: 0.8rem;
            color: #fff;
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
            margin-left: 0.8rem;
        }

        .glitch-subtext { font-size: 0.7rem; color: #555; margin-top: 15px; letter-spacing: 3px; }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-15px); }
            100% { transform: translateY(0px); }
        }

        @keyframes glitch-anim {
            0% { opacity: 1; transform: scale(1); }
            95% { opacity: 1; transform: scale(1); }
            96% { opacity: 0.8; transform: skewX(10deg); }
            97% { opacity: 1; transform: scale(1.02); }
            98% { opacity: 0.9; transform: skewX(-10deg); }
            100% { opacity: 1; transform: scale(1); }
        }

        /* --- HEADER --- */
        .header {
            height: 45px;
            background: #000;
            border-bottom: 1px solid #222;
            display: none; /* Hidden for splash */
            align-items: center;
            padding: 0 1rem;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .logo-group { display: flex; align-items: center; gap: 10px; font-weight: bold; color: #fff; letter-spacing: 2px; font-size: 0.9rem; }
        .logo-icon { height: 18px; filter: grayscale(100%); }

        /* Dropdown Styling */
        .model-select {
            background: #0a0a0a;
            color: #ddd;
            border: 1px solid #333;
            padding: 4px 10px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            outline: none;
            cursor: pointer;
            width: 280px;
            text-transform: uppercase;
        }
        .model-select option { background: #000; color: #fff; }
        .model-select option:disabled { color: #555; font-style: italic; background: #0a0a0a; border-bottom: 1px solid #333; }
        .model-select:hover { border-color: #666; }

        .status-dot { width: 6px; height: 6px; background: #00ff00; border-radius: 50%; box-shadow: 0 0 5px #00ff00; }
        .status-dot.error { background: #ff0000; box-shadow: 0 0 5px #ff0000; }

        /* --- MAIN WORKSPACE --- */
        .workspace {
            display: none; /* Hidden for splash */
            flex: 1;
            flex-direction: row;
            overflow: hidden;
        }

        /* LEFT: Chat Area */
        .chat-panel {
            flex: 2; 
            display: flex;
            flex-direction: column;
            border-right: 1px solid #222;
            background: #080808;
        }

        .chat-history {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        /* Message Styling */
        .message {
            max-width: 95%;
            line-height: 1.6;
            font-size: 0.95rem;
        }
        
        .message-meta {
            font-size: 0.7rem;
            color: #444;
            margin-bottom: 2px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        .message.user { align-self: flex-start; color: #888; border-left: 2px solid #333; padding-left: 10px; }
        .message.ai { align-self: flex-start; color: #eee; }
        .message.system { align-self: center; color: #444; font-size: 0.8rem; text-align: center; margin: 1rem 0; font-style: italic; }
        
        /* RIGHT: Notepad Area */
        .notepad-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #020202;
        }

        .notepad-header {
            padding: 8px 12px;
            background: #0a0a0a;
            border-bottom: 1px solid #222;
            font-size: 0.75rem;
            color: #666;
            display: flex;
            justify-content: space-between;
            letter-spacing: 1px;
        }

        .notepad-area {
            flex: 1;
            background: #020202;
            color: #bbb;
            border: none;
            padding: 1rem;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.85rem;
            resize: none;
            outline: none;
            line-height: 1.5;
        }

        /* --- INPUT BAR --- */
        .input-bar {
            background: #000;
            border-top: 1px solid #222;
            padding: 10px 1.5rem;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .chat-input {
            flex: 1;
            background: #0a0a0a;
            border: 1px solid #333;
            color: #fff;
            padding: 8px 12px;
            font-family: 'IBM Plex Mono', monospace;
            resize: none;
            height: 40px; 
            outline: none;
            font-size: 0.9rem;
        }
        .chat-input:focus { border-color: #666; }

        .send-btn {
            background: #ddd;
            color: #000;
            border: none;
            padding: 0 15px;
            height: 40px;
            font-weight: bold;
            cursor: pointer;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.8rem;
            letter-spacing: 1px;
        }
        .send-btn:hover { background: #fff; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: #333; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
      <style>
         #crt-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9999;
  opacity: 0.2; /* Adjust this value for scanline visibility */
}

.scanline {
  width: 100%;
  height: 100%;
  background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
  background-size: 100% 4px;
  position: absolute;
  pointer-events: none;
  animation: scanline 10s linear infinite;
}

@keyframes scanline {
  0% { transform: translateY(0); }
  100% { transform: translateY(100%); }
}

#crt-overlay::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: 
    radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.3) 100%),
    linear-gradient(to bottom, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 100%);
  box-shadow: inset 0 0 100px rgba(0,255,0,0.1);
  pointer-events: none;
}
@keyframes blink {
  0% { opacity: 0; }
  50% { opacity: 1; }
  100% { opacity: 0; }
}

.loading::after {
  content: '...';
  animation: blink 1s infinite;
}
    </style>
</head>
<body>
<div id="crt-overlay">
  <div class="scanline"></div>
</div>

        <div class="glitch-subtext">AI WRITING TERMINAL</div>
        <div class="glitch-subtext" style="font-size: 0.7rem; margin-top: 15px; opacity: 0.7;"> <div class="orb-container">
            <svg class="glitch-orb" viewBox="0 0 100 100">
                <circle class="orb-circle" cx="50" cy="50" r="45" />
                <polygon class="orb-triangle" points="50,25 78,75 22,75" />
            </svg>INITIALIZING NEURAL INTERFACE...</div>

<!-- HEADER with Dropdown -->
<header class="header">
    <div class="logo-group">
        INK <img src="https://github.com/ghostm68/pantheon/raw/main/mw.inkrealm.info.webp" class="logo-icon"> REALM
    </div>
    
    <!-- MODEL DROPDOWN -->
    <select id="model-select" class="model-select">
        <!-- Disabled items are Headers/Separators -->
        <option value="" disabled>── GEMINI 3 SERIES ──</option>
        <option value="google/gemini-3-pro-preview" selected>Gemini 3 Pro Preview</option>
        
        <option value="" disabled>── GEMINI 2.5 SERIES ──</option>
        <option value="google/gemini-2.5-pro">Gemini 2.5 Pro</option>
        <option value="google/gemini-2.5-flash">Gemini 2.5 Flash</option>
        <option value="google/gemini-2.0-flash-001">Gemini 2.0 Flash</option>
        
        <option value="" disabled>── MISTRAL (EUROPEAN) ──</option>
        <option value="mistralai/mistral-large-2411">Mistral Large 2</option>
        
        <option value="" disabled>── IMAGE & VISION ──</option>
        <option value="google/imagen-4">Imagen 4</option>
        <option value="google/imagen-4-fast">Imagen 4 Fast</option>
        <option value="google/imagen-4-ultra">Imagen 4 Ultra</option>
        <option value="google/gemini-3-pro-image-preview">Nano Banana Pro (Gemini 3)</option>
        <option value="google/gemini-2.5-flash-image-preview">Nano Banana (Gemini 2.5)</option>
    </select>

    <div style="display: flex; align-items: center; gap: 10px;">
        <span id="status-text" style="font-size: 0.65rem; color: #666;">CONNECTING</span>
        <div id="status-dot" class="status-dot"></div>
    </div>
</header>

<!-- MAIN WORKSPACE -->
<div class="workspace">
    <!-- LEFT: CHAT -->
    <div class="chat-panel">
        <div class="chat-history" id="chat-history">
            <div class="message system">System Ready. Select a model to begin writing.</div>
        </div>
        
        <!-- COMPACT INPUT -->
        <div class="input-bar">
            <textarea id="user-input" class="chat-input" placeholder="Input prompt..."></textarea>
            <button id="send-button" class="send-btn">WRITE</button>
        </div>
    </div>

    <!-- RIGHT: NOTEPAD -->
    <div class="notepad-panel">
        <div class="notepad-header">
            <span>SCRATCHPAD</span>
            <span style="cursor: pointer;" onclick="localStorage.setItem('inkrealm_notes', ''); document.getElementById('notepad').value='';">CLEAR</span>
        </div>
        <textarea id="notepad" class="notepad-area" placeholder="Notes auto-save locally..."></textarea>
    </div>
</div>

<script>
    class InkRealmTerminal {
        constructor() {
            this.currentModel = 'google/gemini-3-pro-preview'; // Default updated
            this.chatHistory = [];
            this.isOnline = false;

            this.systemPrompt = `You are a dedicated creative writing engine.
            Rules:
            1. Output ONLY the requested creative text.
            2. Do NOT act like a chat assistant. No "Sure," or "Here is...".
            3. If the user provides a partial sentence, continue it seamlessly.
            4. Maintain high literary quality and requested tone.`;

            this.init();
        }

        async init() {
            this.runSplash();
            this.setupEvents();
            this.loadNotepad();
            // Allow splash to finish before connecting
            setTimeout(() => this.connectPuter(), 1000);
        }

        runSplash() {
            const splash = document.getElementById('glitch-splash');
            const header = document.querySelector('.header');
            const workspace = document.querySelector('.workspace');
            
            setTimeout(() => {
                splash.style.opacity = '0';
                splash.style.transition = 'opacity 1s ease';
                setTimeout(() => {
                    splash.style.display = 'none';
                    header.style.display = 'flex';
                    workspace.style.display = 'flex';
                }, 1000);
            }, 3000); 
        }

        async connectPuter() {
            try {
                if (typeof puter === 'undefined') throw new Error("SDK Missing");
                
                this.isOnline = true;
                document.getElementById('status-text').textContent = "ONLINE";
                document.getElementById('status-dot').style.background = "#00ff00";
            } catch (e) {
                console.error("Connection failed", e);
                this.isOnline = false;
                document.getElementById('status-text').textContent = "OFFLINE";
                document.getElementById('status-dot').classList.add('error');
            }
        }

        setupEvents() {
            // Dropdown change
            document.getElementById('model-select').addEventListener('change', (e) => {
                this.currentModel = e.target.value;
                this.addSystemMessage(`MODEL SWITCHED: ${this.currentModel.split('/').pop().toUpperCase()}`);
            });

            // Send button
            document.getElementById('send-button').addEventListener('click', () => this.generate());

            // Enter key
            document.getElementById('user-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.generate();
                }
            });

            // Notepad Auto-save
            document.getElementById('notepad').addEventListener('input', (e) => {
                localStorage.setItem('inkrealm_notes', e.target.value);
            });
        }

        loadNotepad() {
            const saved = localStorage.getItem('inkrealm_notes');
            if (saved) document.getElementById('notepad').value = saved;
        }

        async generate() {
            const input = document.getElementById('user-input');
            const prompt = input.value.trim();
            if (!prompt) return;

            // Add User Message
            this.addMessage('user', prompt);
            input.value = '';

            // Add Loading Indicator
            const loadingId = this.addLoading();

            try {
                let text = "";
                
                if (this.isOnline) {
                    text = await this.callAI(prompt);
                } else {
                    text = this.getSimulation(prompt);
                }

                this.removeLoading(loadingId);
                this.addMessage('ai', text);

            } catch (error) {
                console.error(error);
                this.removeLoading(loadingId);
                // If call fails, use fallback and warn user
                const fallback = this.getSimulation(prompt);
                this.addMessage('ai', `[OFFLINE MODE / ERROR: ${error.message}]<br><br>${fallback}`);
            }
        }

        async callAI(prompt) {
            // Check if it's an image model request
            if (this.currentModel.includes('image') || this.currentModel.includes('imagen')) {
                 return await this.callImageGen(prompt);
            }

            const completion = await puter.ai.chat.completions.create({
                model: this.currentModel,
                messages: [
                    { role: 'system', content: this.systemPrompt },
                    ...this.chatHistory,
                    { role: 'user', content: prompt }
                ],
                temperature: 0.9,
                max_tokens: 4000
            });

            const response = completion.choices[0].message.content;
            
            this.chatHistory.push({ role: 'user', content: prompt });
            this.chatHistory.push({ role: 'assistant', content: response });
            if (this.chatHistory.length > 8) this.chatHistory = this.chatHistory.slice(-8);

            return response;
        }
        
        async callImageGen(prompt) {
            try {
                const image = await puter.ai.txt2img({
                    model: this.currentModel,
                    prompt: prompt
                });
                // Assuming image returns a URL
                return `<img src="${image.src || image.url}" style="max-width:100%; border:1px solid #333; margin-top:10px;">`;
            } catch(e) {
                return `[IMAGE GENERATION FAILED: ${e.message}]`;
            }
        }

        getSimulation(prompt) {
            const fallbacks = [
                "The neon rain washed away the digital footprints before the tracers could find them.",
                "Silence is not empty; it is full of answers you are not ready to hear.",
                "The city skyline looked like a broken circuit board against the velvet sky.",
                "Memory is a glitch in the system, a file that refuses to be deleted."
            ];
            return fallbacks[Math.floor(Math.random() * fallbacks.length)];
        }

        addMessage(role, text) {
            const container = document.getElementById('chat-history');
            const div = document.createElement('div');
            div.className = `message ${role}`;
            
            const meta = role === 'user' ? 'INPUT' : `OUTPUT`;
            
            // Format newlines
            const formattedText = text.replace(/\n/g, '<br>');

            div.innerHTML = `
                <div class="message-meta">${meta}</div>
                <div>${formattedText}</div>
            `;
            
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        addSystemMessage(text) {
            const container = document.getElementById('chat-history');
            const div = document.createElement('div');
            div.className = 'message system';
            div.innerHTML = text;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        addLoading() {
            const container = document.getElementById('chat-history');
            const div = document.createElement('div');
            div.className = 'message ai';
            div.id = 'loading-indicator';
            div.innerHTML = `<div class="message-meta">PROCESSING</div><div>...</div>`;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
            return 'loading-indicator';
        }

        removeLoading(id) {
            const el = document.getElementById(id);
            if (el) el.remove();
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        window.app = new InkRealmTerminal();
    });
</script>

</body>
</html>
